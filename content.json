[{"title":"面试/复盘/4.27其他面试","date":"2021-06-22T15:55:01.011Z","path":"2021/06/22/面试/复盘/4.27其他面试/","text":"go的内存管理 go和php的区别 go项目的调用过程 es的日志量 每一行一个单词 1：cookie与session的区别2：mysql性能优化（慢日志，explain，索引，内存碎片化）3：聚簇索引与非聚簇索引（B+树与B树，覆盖索引，普通索引，主键索引）4：redis主从同步（日志&amp;&amp;rdb）5：redis实现延时队列6：令牌桶&amp;&amp;漏斗限流7：进程间通信的几种方式与限制条件8：项目9：三道LeetCode的esay难度题目 MySQL的存储引擎的区别B树与B+树的区别Join与In的查询效率有没有使用分布式或者微服务为什么使用SpringBoot而不使用SSM，区别是啥？Redis里面使用的Hash算法是什么？Redis不设置过期时间，他的过期时间是多久？你在系统开发中上从宏观角度有没有一些设计？JDK8里面的一些新东西是？两个List怎么去重？Limit 分页会有什么效率问题？","tags":[]},{"title":"股票/股票初级","date":"2021-06-22T15:55:01.009Z","path":"2021/06/22/股票/股票初级/","text":"股票初级股票入门股票投资五大流派 技术投资派：通过分析股票的价格走势，来预测股票未来涨跌 宏观投资派：逻辑是整个市场经济向好，股市就会向好，研究经济就可以指导股票投资 有效市场派：认为市场大部分时候对股票的定价是正确的 成长投资派（预测未来）：更关注公司未来是否有足够高的增长 价值投资派（把握现在）：看重现在公司是否有足够低的价格，低价高卖就是价值投资的本质价值投资价值投资方法捡烟蒂投资法 本杰明.格雷厄姆：100%价值投资法，独创安全边际理论 烟蒂股：毫不起眼，甚至被抛弃的公司 需要的成本远低于本身的价值，继续下跌概率小，上涨概率大于下跌概率好公司投资法 巴菲特：喜欢买好公司，偏爱食品行业 投资核心：找到好公司，低价买入 好公司的价值最终一定会显现在股价上 天时：看准入场时机，在股票市场便宜的时候进场买买买 一家公司的价值=现在公司的价值+未来公司能赚取的价值 市盈率(PE)=市值/净利润=买下公司需要的钱/每年能赚到的钱PE越小，回本年限越短，越有投资价值 市净率（PB)=市值/净资产=买下公司需要的钱/属于公司自己的资产 PB越小，价格越低，越有投资价值 A股3000=沪深300+中证500+其他各类股票 找准入场时机：用沪深300和中证500估值处于低估，此时可入场当沪深300和中证500中任一个PE，PB同时满足： 1.PE处于近十年数值的0-50%2.PB处于近十年数值的0-20% 可入场投资的三种情况：沪深300PE，PB同时满足条件，中证500没有满足中证500PE，PB同时满足条件，沪深300没有满足沪深300和中证500的PE，PB都同时满足条件 实操理杏仁官网-搜索框输入“沪深300”查询该指数的数据选“PE-TTM，加权平均值，十年”，可以看到PE图PE－TTM：就是PE，TTM是一种更为精确计算PE的方式加权平均值：把沪深３００的所有公司的市值相加除以净利润之和，相当于把这３００家公司“合并”成一家大公司计算PE１０年：通常７－１０年，中国股市会经过一个完整的涨跌大周期，选择十年，能较客观地判断当前估值相对于过去１０年是高还是低PE分位点：把过去１０年PE从小到大排序，当前PE所处位置１００％表示当前PE是最大值，５０％表示当前PE处于中间位置点击PB，可以查看PB图搜索中证５００，查看PE，PB判断某天是否适合入场，满足其中一个即可沪深３００当天PE分位点＜５０％且PB分位点＜２０％，十年加权平均值中证５００当天PE分位点＜５０％且PB分位点＜２０％，十年，加权平均值地利：合理布局资金，建立自己的投资组合，规避风险股市风险系统性风险:整个股票市场存在的下跌风险，我们需先估值再入市政策风险:政策改变导致企业生存条件变化购买力风险:通货膨胀的风险利率风险:市场利率会不断波动非系统性风险:单只股票本身的风险经营风险:公司经营的错误决策可能导致公司业绩大幅下滑信用风险:公司违背信用所产生的风险道德风险:违背道德事件，如三鹿的“毒奶粉事件”规避风险规避系统风险:先估值再入市规避非系统风险:构建组合投资，资金分散到多个行业的多个股票上，鸡蛋不要放在同一个篮子里回避风险时，并不是买的股票越多越科学，持有4-8只股票是比较经济，有效的做法分散行业：同行业资金占比不要超过30%人和：学会建设过硬的心理素质白马组合“好公司”投资法：赚业绩提升的钱初筛白马股买股票的条件资金：投资的必要条件心态：优秀投资者必备的素质选股：开始买股票最重要的事情，一个好的股票，上涨的时候更多的回报，下跌的时候更大的耐心头脑清晰，理性看待价格上涨可能跟随价值上涨可能只是围绕价值波动白马股票：信息相对可靠，长期业绩优秀，投资回报率高投资回报率：投资多少和能赚多少的比例股票投资回报率就是投资收益率=[（卖出价格/买入价格）-1]100%年化复合收益率=【（卖出价格/买入价格）^（1/n）-1】100%，n是投资年限净资产收益率（ROE）=净利润/净资产，代表了企业赚钱能力ROE越高，股票的年化收益率就越高初筛条件ROE连续7年&gt;=15%上市时间&gt;5年，因为上市时间太短的话，业绩不够稳定初筛方法 1.打开同花顺旗下“i问财”网站（https://www.iwencai.com）2.文本框输入查询条件：2012年到2018年ROE大于等于15%，2019年06月30日ROE大于等于7.5%，上市时间大于5年，点击按钮“问一下财”，系统自动识别条件，并把输入的条件用“且”的关系关联起来，查出股票数据3.初步筛选出了43个白马股了，可以导出数据注意：财报披露是有延迟的（速记：1214）第一季度结束后一个月内公布第二个季度结束后两个月内公布第三季度结束后一个月内公布第四季度即年报是结束后4个月内公布剔除周期股经济周期：国民经济呈现扩张与紧缩交替波动变化必然发生循环往复：复苏，繁荣，衰退，萧条，类似四季循环周期性行业：业绩紧跟经济周期起起伏伏，比如：汽车行业非周期性行业：受经济周期影响较小，经营业绩更稳定，比如：医药行业，食品行业周期股：受经济周期影响大，所处行业属于周期性行业四类要避开的行业（周期性行业）作为工业基础原材料的大宗商品相关行业（主要用于经济发展）比如：采掘服务，钢铁，化工合成材料，化工新材料，石油矿业开采，化学制品等航运业（运输货物）比如：远洋运输，港口航运，机场航运，交通设备服务等非生活必需品行业，及与之相关的行业（非必需）如：国防军工，汽车零件，汽车，建筑材料，建筑装饰，房地产等非银行的金融行业如：证券，保险及其他方法1.“i问财”中初筛白马股，输入查询条件：2012年到2018年ROE大于等于15%，2019年06月30日ROE大于等于7.5%，上市时间大于5年，行业。点击按钮“问一下财”，查询数据并导出2.剔除周期股，打开表格，把所属行业是周期性行业的数据剔除剔除基本面转坏的股票评估业绩下滑，四个指标有一个为负数就剔除该股最近年度营收增长率 = （本年营业收入 - 去年营业收入） / 去年营业收入最近年度净利润增长率 = （本年净利润 - 去年净利润） / 去年净利润最近季度营收增长率 = （本季度营业收入 - 去年同季度营业收入） / 去年同季度营业收入最近季度净利润增长率 = （本季度净利润 - 去年同季度净利润） / 去年同季度净利润方法1.“i问财”输入查询条件：2012年到2018年ROE大于等于15%，2019年6月30日ROE大于等于7.5%，营收增长率和净利润增长率，上市时间大于5年，行业，2018年营收增长率和净利润增长率2.去掉不必要的列，导出数据3.导出的表格筛选行业，去掉周期性行业4.筛选出最近季度和最近年度的营收增长率和净利润增长率大于0，排除掉小于0的即业绩下滑的股财报三表分析财报：记录公司所有经营事务的报表，分为季度报表，半年报表，年度报表利润表（损益表）：体现公司在一段时间内是赚钱还是亏钱营业利润=营业收入 - 营业成本 - 三费营业收入：卖东西的收入，只要卖出东西，无论是否收到钱都计入营业成本：购买生产货物的原材料等所付出的钱三费：管理费用，销售费用，财务费用净利润 = 营业利润 - 所得税资产负债表记录某时公司有多少钱，财，物以及欠别人多少钱现金流量表公司现金流入流出情况，开支流水账，记录花出去多少钱，收到多少钱经营活动现金流量利润表投资现金流量资产筹资活动现金流量负债识别信息相对可靠如何识别收入美化，识别真货假卖小熊定理1：识别真货假卖，是否存在连续两年应收账款增长幅度大于营收增长幅度，存在则不通过检验实操方法理杏仁-输入查询的某股票利润表-我们需要了解最近3年增长情况，所以查询最近4年数据找到营业收入，把数据复制进表格中,计算每年营业收入增长金额资产负债表-应收账款-数据复制进表格，计算每年应收账款增长金额每年应收账款增长金额-营业收入增长金额算出结果，如果连续两年结果大于0，表示连续两年应收账款增长幅度大于营业收入增长幅度，则不通过小熊定理1，要当心如何识别资产美化资产负债表：记录公司某时有多少钱财物，欠多少钱资产货币资金（现金）：顾客找零，临时补货等应收账款：白条，别人欠你的钱存货：原材料和耗材等预付款项：预先支出房租等固定资产：设备，厂房，土地等负债应付款项：欠供应商的贷款短期借款：如借朋友的钱，一年内还长期借款：如借银行的钱，为期5年所有者权益（净资产）：属于公司自己的资本公积金未分配利润核心：资产=负债+所有者权益问题主要在存货上，存货不仅指生产出的货物，还包括生产用的原材料，生产过程中的半成品，财报的存货只能看到资金总额，这就给了别有用心的公司一个机会识别存货造假小熊定理2：连续两年存货增长大于营业收入增长，这家公司存货可能有问题实操方法1.理杏仁网站查询某股票信息，在利润表中找到连续4年的营业收入数据，并计算出营业收入增长金额2.在资产负债表中找到连续4年的存货数据，并计算存货增长金额3.验证小熊定理2，比较每年营业收入增长金额和存货增长的差异，用当年存货增长减去营业收入增长金额结果大于0，说明存货涨幅更大，小于0则说明营业收入丈夫更大当出现连续2年结果都大于0，说明公司连续两年存货增长金额大于营业收入增长金额，不通过小熊定理2，要当心了识别资产安全（鉴别公司是否有破产的风险）小熊定理3：如果一家公司的流动负债远大于流动资产的话，说明这家公司已经非常接近破产了流动资产：一年内可以变现的资产，如货币资金，存货，预付款项流动负债：一年内必须要还的钱，如应付账款，短期借款流动比率 = 流动资产 / 流动负债如果流动比率小于1，说明流动资产小于流动负债，危险的信号实操方法理杏仁-查询股票资产负债表中最近3年的流动比率，最近3年有2年都小于1就要当心了i问财也可以查询除银行股外，所选公司只要有一个定理不能通过检验，就要剔除小熊定理1能看出公司是否有美化收入嫌疑小熊定理2能看出公司是否有美化资产的嫌疑小熊定理3能轻松鉴别公司是否有破产风险自由现金流如此重要，加分项小熊定理4：当一家公司经营活动现金流量净额远大于净利润，说明这家公司可能有隐藏的盈利能力，有可能是座金矿理杏仁-查询公司-现金流量表-近三年经营活动产生的现金流量净额-和净利润对比小熊定理5：自由现金流是衡量公司现金流情况的指标，代表公司真正能自由运用的资金，比净利润更真实，更难作假自由现金流=经营活动产生的现金流量净额-资本开支资本开支是现金流量表中的购建固定资产，无形资产和其他长期资产支付的现金理杏仁-查询公司-财务指标-现金流量里面的自由现金流大于0就加分了实操：构建白马组合筛选步骤投资回报率高ROE连续7年大于等于15%，上市时间大于5年长期业绩优秀剔除周期股，看行业剔除当下业绩显现下滑迹象的公司信息相对可靠小熊三大定理检验经过筛选的股票，财报信息是否可靠判断股票价格股票的贵与便宜相对价值而言的，估值体现价格和价值的关系PE分位点和PB分位点小于50%理杏仁-查询公司-价值分析-PE分位点和PB分位点（10年数据）历史看前复权，现在看股价怎么买PE分位点升序排列，优先买PE分位点低的，平均分配资金PE升序，整理筛选出来的公司找出它们当时的股价，计算购买一手的价格根据资金量分配选择股票数量，同行业不能超过30%，行业看二级行业同行业股票数量不超过30%，即公司数量不超过30%同行业资金占比也不超过30%卖出股票价格高于价值了，你贵了基本面转坏了，你变了，每年一次筛选对比发现更好更便宜的，别人比你更好了稳住心态，长期持有短期可能下跌，长期价格回归价值总结PE分位点升序排列，优先买PE分位点低的，平均分配资金每年筛选一次对比调仓，贵了，变了就剔除干货补充容易出白马股的行业，一般来说，有护城河的公司都会有较高的投资回报率，也有不错的业绩。护城河无形资产护城河：看不见摸不到的资产品牌护城河：大家耳熟能详的各种品牌，就是公司想要打造的品牌护城河品牌溢价护城河：可以卖得比同类产品贵的能力，就是品牌溢价能力，这种公司就有品牌 溢价护城河。有这种护城河的公司产品，即使价格卖得高卖得贵，消费者为了这个牌子也 会买，比如说贵州茅台，比如说苹果手机。品牌搜索护城河：有这种护城河的公司产品，在我们想买什么的时候，会出现在我们脑子里。比如说我们想买牛奶，第一反应可能是伊利，可能是蒙牛专利护城河：专利就是只有我有的权利有专利护城河的公司，就是那种可以持续性研发出产品，并且申请出专利的 公司，比如说大型药厂政府授权护城河:政府授权的是你能不能进入这个行业比较典型的有这个护城河的公司是赌场，在内地，赌场就禁止经营，而澳门现在也不会批准建新的赌场，所以，澳门那几家赌场的竞争对手并不会增加！转换成本护城河如果一个产品的用户，更换这个产品时需要付出很多代价或成本，我们就说 这个产品具有转换成本，这家公司具有转换成本护城河。如果一家医院要换信息系统，它会面临怎样的麻 烦？数据转移医生，护士学习新系统核对旧病例，导入是否完整网络效应护城河严格来说是转换成本的一种。 因为互联网的日益发达，受到了越来越多的重视，很典型的公司就是腾讯控股。像微信这种，随着使用人数的增多，产品价值越高的公司，就是有网络效应 护城河的公司。规模效应护城河规模带来的效应，生产数量越多固定资产成本越低固定成本（厂房设备等固定资产）的总额不会随着成品数量变化，但是 随着生产数量的增多，每个产品中固定成本的量会变小。易出护城河的行业（速记：白衣小软妹），可以优先选择好行业里的公司白酒行业、医药行业、软件行业、媒体行业、消费行业通过估值四象限快速判断一家公司的状态PE 是从企业盈利的角度考察现在的股价是不是合理，而 PB 是从企业的净资产角度考察现在的股价是不是合理。粗略来分，我们可以把大于 50%的分位点称为高，把小于 50%的分位点称 为低。估值四象限第一象限：高 PB，高 PE泡沫象限，远离pe、pb 越高，说明整个 市场越贵，下跌的可能越大。被疯狂炒作的个股，比方说 2015 年妖股第一名暴风集团。第二象限：低 PB，高 PE，分析公司业绩未来是否有变好的可能企业自身运营不善，避开周期性行业低估期，买入持有至行业回暖，也有可观的收益第三象限：低 PB，低 PE，大概率是比较合适的投资机会，辨别PE是真低还是价低（盈利能力下降，财报是否体现）市场处于熊市的末期，此时由于熊市长期的下跌导致大家的投 资情绪都过于悲观，会使得很多股票的价格跌到实际价值以下，出现大量的低 PB、低 PE 股票，这时候意味着，投资的机会来了。企业遭遇经营困境、或行业政策、竞争态势等外部环境发生 不利变化。由于市场有时会提前并且迅速做出反应，导致公司股价下降，市 值变得很低，自然的 PB 就会很低。PE“真低”财报中的数据已经显示出公司盈利能力的下降，投资者们 看到公司盈利下降了，纷纷卖出，公司市值必然下降，市值与净利润同时下降导 致的低 PE，就是 PE“真低”。只要公司未来盈利能力可以恢复，就是好的入场 时机。PE“假低”公司业绩的披露有滞后性，而 PE 的计算又是基于最近披露的净利润， 所以当最近一期公司财报并没有显示出业绩下滑，也就是说净利润仍然是高的， pe=市值/净利润，公司的 PE 依然很低。一旦未来公司财报显示出公司的盈利能力快速下滑，那很可能会出现股价越 跌，PE 越高的情况。因为虽然股价在下跌，但盈利下跌速度更快，可能直接跌成负的了。 这就是我们必须尽力避免的低价值陷阱，也就是 PE“假低”。第四象限：高 PB，低 PE英雄象限，避开PB 高，意味着投资者们特别看好公司的发展，对公司的盈利能力有着很高的期待，毕竟市场给予了比净资产高很多倍的溢价嘛！一旦公司盈利不达预期，曾经追捧的那些投资者们就会纷纷弃他而去， 导致股价下跌。PB高，不用管PE低不低，直接避开分红过后需要除权除息，所以股价必然下降分红一种是上市公司直接给股东送股票，这种称为“股票股利”公司的股价=总市值/总股数，总股数增加了，每股的价格当然也会减少，这种行为就叫做除权。另外一种是现金分红，就是公司直接给股东发现金，这种称为“现金股利”发现金股利的时候，会从股价中将这一部分股利扣除，这就叫做除息填权公司的价值短期内变动幅度有限，只要大家看好公司的价值，股 价降低了公司价值没有变，当然会有人去买，因此，除权除息后，股价都会涨回 和原来差不多，这个过程称之为填权。红利税红利税并不是在分红派息那天扣除的，而是在卖出股票的时候 扣除，只要持股超过一年，就不需要缴纳，可见，咱们股市的监管方，也是希望 大家做长期的价值投资者，而非炒作的投机者。什么公司不能碰第一种，大品牌更可靠首先，知名企业有着很大的曝光率，更容易被发现财务造假。其次，他们财务造假的成本太高。第二种，不要 ST。股票名称前带有“ST”、“ST”、“SST”、“SST”、“NST”标识的， 一定不要投！有上述标识的股票意味着，该公司至少连续两年亏损，将被证监会处理，面 临整改或者退市。ST 代表的就是亏损股第三种，曾经出现过违反道德规范、财报作假等重大丑闻的，被证监会立案调查 还未有结果的公司不要买。只要在百度中用“公司名+证监会”， 这一组关键词搜索，就能看到相关的信息。便宜组合“捡烟蒂”投资法便宜组合：赚股价回升的钱，不太挑剔股票质量，主要看折扣筛选指标双低组合，低PE低PB0&lt;PE&lt;100&lt;PB&lt;1.5大方分钱股息率&gt;3%股息率=公司过去一年的累计现金分红/公司市值，A股公司平均股息率约为3%实操筛选理杏仁-选股-基本面选股选择范围-A股市场-沪深两市条件设置-基本指标-点击筛选便宜组合的三个指标市盈率选PE-TTM（扣非）扣非：扣除非经常性损益（利润表中一部分和公司正经运营业务无关）不含商誉的PB公司收购其他公司时超过净资产的部分，是资产的一部分，但本质不是真正的资产股息率两个选股条件PB（不含商誉）分位点（10年），股价时间选择最近时间按照筛选条件，选好最大值最小值，开始选股，最后导出文件排序筛选法PE，PB升序排列，股息率降序排列，三个指标排名加总，算出总排名实操分别在PE，PB，股息率右边增加列PE排名，PB排名，股息率排名。再加一列综合排名用RANK.EQ函数计算PE排名，PB排名，股息率排名数值-想要排序的那个数值引用-数值所在的数据集合排序方式1：升序0：降序计算综合排名：把PE排名，PB排名，股息率排名三个排名相加综合排名升序排列具体筛选8-10只构建便宜组合根据综合排名从低到高依次挑选，行业要分散：同一行业公司不要超过30%用PB分位点进一步挑选低估股票，PB分位点&lt;20%加入组合PB（不含商誉）分位点（10年）：把过去10年的PB从小到大排列，现在PB所在的位置PB分位点&lt;20%，现在是低估，适合买入PB分位点&gt;50%，现在是高估，不适合买入资金分配根据资金量确定便宜组合的股票数量同一行业股票数量和资金不超过30%资金均分确定价格最高的买一手，其余股票金额往这个金额上靠就可以了筛选数量不够时放宽筛选条件寻找别的投资机会持币观望，等待入场时机被动投资每隔半年调仓一次，将组合整体估值降低每隔半年重新筛一次便宜组合将最新筛出的便宜组合和原来组合对比新旧组合重合部分保留卖掉旧组合里有，但新组合里没有的股票补入就组合里没有，但新组合里有的股票清楚投资原理，投资方法了解攀升强度，明白回撤幅度具备耐心和坚持才配得上优厚的回报轻松实践买股票常识A股交易时间：周一到周五每天4小时交易时间（法定休假日除外），上午9:30-11:30，下午13:00-15:00K线图（蜡炬图）蜡炬图阳线：红色的，代表股价上涨，当天收盘价大于开盘价即收盘价在上开盘价在下阴线：绿色的，代表股价下跌，当天收盘价小于开盘价即开盘价在上收盘价在下阳线和阴线都有上影线和下影线分部表示最高价和最低价计算周期日K线：最常用，以当天开盘价，收盘价，最高价，最低价来画的Ｋ线图周K线：以周一开盘价，周五收盘价，全周最高价和最低价来画的K线图月K线：以一个月第一个交易日的开盘价，最后一个交易日收盘价，全月最高价和最低价来画的K线图季K线年K线每根Ｋ线下面对应有一条红色或绿色的条形图，代表交易量（一段时间内成交的股票数量，受供求关系影响）交易单位以“手”为单位，１手＝100股, 1-99股称为零股买入最低单位为手分红送股可能有零股，卖出可以有零股，但是零股必须一次性卖出A股交易费用（沪市和深市）无论是基金开的还是咱们股初扫码开的华泰优惠开户，都是调整成股票万分之1.8，起点5元， 基金万分之1，起点0.1元印花税国家税务局卖出收，成交金额的千分之一过户费中登公司买入和卖出都收，成交金额的千分之0.02佣金证交所证券公司买入和卖出都收，最高千分之3，最低5元报价方式限价委托（常用）用户限定价格，价格可控，交易时间不可控好处：价格可控，当股价到达了设置的价格成交坏处：如果股价始终高于限定的价格，就需要耐心等待，也可能当天成交不了市价委托（不常用）只指定交易数量，价格不可控，交易时间可控好处：即时成交坏处：成交价格可能偏贵特色涨跌停板制度股票上涨幅度和下跌幅度只能是上一个交易日收盘价的10%ST开头的股票，每日涨跌停幅度限制只有5%新股首日上市股价涨幅不受10%限制，但是最高幅度不能超过发行价的44%交易制度：T+1交易，忌频繁交易当天买入的证券不能当天卖出，第二天才可以卖出当天卖出股票收回的资金只能用来买新的股票，不能提取。第二天才可提取人和：股海沉浮，锦囊妙计1.贪多嚼不烂入门简单，严格执行投资计划，会获得合理收益的。精通难，想要超额收益，需要付出超额努力2.笑看涨跌，波澜不惊面对股价大幅度下跌，要相信组合的力量，不要每天看盘，一个月一次就够了3.保持耐心，长期持有时间是财富自由的基本条件#","tags":[]},{"title":"商业/行业调研步骤","date":"2021-06-22T15:55:01.006Z","path":"2021/06/22/商业/行业调研步骤/","text":"基本的研究框架一般常见的研究框架包括以下这些： 产品 这个行业的主要产品是什么？ 产品的主要形态是什么？ 满足了用户哪一方面的需求？ 产品的替代品包括什么？ 产品的关键技术是哪一项？ 产品的成本结构如何？ 市场 公司的市场定位？ 公司的主要用户？ 市场空间有多大？ 近几年的市场增长率有多高？ 预计未来几年的市场增速如何？ 市场的主要玩家是谁？ 行业概括 基本的行业术语 行业的发展历程和变迁 行业的监管情况和主要政策是什么？ 行业发展的有利因素和不利因素 行业发展的瓶颈 行业目前所处的周期 行业的供应链情况 用PESTEL模型分析，这个行业如何？（PESTEL模型如下） P：政治因素，是否是公有设施行业？是否受到政策和监控的严控？如房地产 E：经济因素，哪些经济因素影响了这个行业的发展？如奢侈品 S：社会因素，社会风俗和思想开放程度对这个行业有多大的影响？如医美 T：技术因素，技术是如何影响这个行业的？如手机 E：环境因素，环保政策和环保理念如何影响行业发展？如新能源汽车 L：法律因素，某些法律法规的出台对行业的影响，如广告法影响自媒体等。 竞争 行业的竞争情况如何，是完全竞争？寡头垄断？还是寡头竞争？ 业内几个主要玩家的盈利模式分别是怎样的？ 在竞争胜出的关键行业因素是什么？ 该行业是否受到海外竞争的压力","tags":[]},{"title":"【第一课】etcd&zookeeper","date":"2020-03-23T08:14:00.000Z","path":"2020/03/23/面试/要点整理/etcd&zookeeper/","text":"etcd 和zookeeper123etcd是一个高可用的键值存储系统，主要用于共享配置和服务发现。etcd是由CoreOS开发并维护的，灵感来自于 ZooKeeper 和 Doozer，它使用Go语言编写，并通过Raft一致性算法处理日志复制以保证强一致性。Raft是一个来自Stanford的新的一致性算法，适用于分布式系统的日志复制，Raft通过选举的方式来实现一致性，在Raft中，任何一个节点都可能成为Leader。Google的容器集群管理系统Kubernetes、开源PaaS平台Cloud Foundry和CoreOS的Fleet都广泛使用了etcd。etcd 集群的工作原理基于 raft 共识算法 (The Raft Consensus Algorithm)。etcd 在 0.5.0 版本中重新实现了 raft 算法，而非像之前那样依赖于第三方库 (https:&#x2F;&#x2F;github.com&#x2F;goraft&#x2F;raft) 。raft 共识算法的优点在于可以在高效的解决分布式系统中各个节点日志内容一致性问题的同时，也使得集群具备一定的容错能力。即使集群中出现部分节点故障、网络故障等问题，仍可保证其余大多数节点正确的步进。甚至当更多的节点（一般来说超过集群节点总数的一半）出现故障而导致集群不可用时，依然可以保证节点中的数据不会出现错误的结果。 12345Zookeeper是一个用户维护配置信息、命名、分布式同步以及分组服务的集中式服务框架，它使用Java语言编写，通过(http:&#x2F;&#x2F;www.stanford.edu&#x2F;class&#x2F;cs347&#x2F;reading&#x2F;zab.pdf)协议来保证节点的一致性。因为Zookeeper是一个CP型系统，所以当网络分区问题发生时，系统就不能注册或查找服务。etcd是一个用于共享配置和服务发现的高可用的键值存储系统，使用Go语言编写，通过Raft来保证一致性，有基于HTTP+JSON的API接口。etcd也是一个强一致性系统，但是etcd似乎支持从non-leaders中读取数据以提高可用性；另外，写操作仍然需要leader的支持，所以在网络分区时，写操作仍可能失败。在原生接口和提供服务方式方面，etcd更适合作为集群配置服务器，用来存储集群中的大量数据。方便的REST接口也可以让集群中的任意一个节点在使用Key&#x2F;Value服务时获取方便。ZooKeeper则更加的适合于提供分布式协调服务，他在实现分布式锁模型方面较etcd要简单的多。所以在实际使用中应该根据自身使用情况来选择相应的服务。 1并且在面对网络分区的时候，为了保持一致性，读取的可用性是可以牺牲的。 能否用redis替代etcd123456789不能 1、redis 没有版本的概念，历史版本数据在大规模微服务中非常有必要，对于状态回滚和故障排查，甚至定锅都很重要2、redis 的注册和发现目前只能通过 pub 和 sub 来实现，这两个命令完全不能满足生产环境的要求，具体原因可以 gg 或看源码实现3、etcd 在 2.+版本时，watch 到数据官方文档均建议再 get 一次，因为会存在数据延迟，3.+版本不再需要，可想 redis 的 pub 和 sub 能否达到此种低延迟的要求4、楼主看到的微服务架构应该都是将 etcd 直接暴露给 client 和 server 的，etcd 的性能摆在那，能够承受多少的 c&#x2F;s 直连呢，更好的做法应该是对 etcd 做一层保护，当然这种做法会损失一些功能5、redis 和 etcd 的集群实现方案是不一致的，etcd 采用的是 raft 协议，一主多从，只能写主，底层采用 boltdb 作为 k&#x2F;v 存储，直接落盘6、redis 的持久化方案有 aof 和 rdb，这两种方案在宕机的时候都或多或少的会丢失数据总结，瑞迪斯从来没有想过抢 etcd 在服务注册和发现的饭碗，目前的架构来说也抢不动，在缓存方面目前在性能和功能也无出其右； etcd 只关注在服务注册与发现方面，非要当做 k&#x2F;v 存储来用（丢弃 watch 特性而言）也可以用，性能也不错，但只能说你选错对象了 1pubsub 不会保留历史信息, 收到就行, 收不到也不会重复通知, 换句话说, 你必须客户端永远在线, 才能收到 sub 的信息, 一旦客户端网络短时间出问题, 就收不到变更通知了, redis 可以做, 但是不是用 pubsub 做, 而是要自己做一个定时的轮询, 时刻保持客户端信息最新 123456CAP： C：Consistency 即一致性A：Availability 即可用性P：Partiton tolerence 即分区容忍性etcd是CP的 而redis是AP的","tags":[{"name":"golang","slug":"golang","permalink":"http://lcf12307.github.io/tags/golang/"}]},{"title":"【第一课】golang常考知识点","date":"2020-03-19T08:14:00.000Z","path":"2020/03/19/面试/要点整理/go/","text":"数组和切片的区别12数组类型的值（以下简称数组）的长度是固定的，而切片类型的值（以下简称切片）是可变长的。我们其实可以把切片看做是对数组的一层简单的封装，因为在每个切片的底层数据结构中，一定会包含一个数组。数组可以被叫做切片的底层数组，而切片也可以被看作是对数组的某个连续片段的引用。 golang中的引用类型1在golang中只有三种引用类型它们分别是切片slice、字典map、管道channel。其它的全部是值类型，引用类型可以简单的理解为指针类型，它们都是通过make完成初始化 进程 线程 和 协程123456789101112131415 进程、线程(内核级线程)、协程(用户级线程)协程是一种用户态的轻量级线程，协程的调度完全由用户控制（进程和线程都是由cpu 内核进行调度）。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。对于 进程、线程，都是有内核进行调度，有 CPU 时间片的概念，进行 抢占式调度（有多种调度算法）对于 协程(用户级线程)，这是对内核透明的，也就是系统并不知道有协程的存在，是完全由用户自己的程序进行调度的，因为是由用户程序自己控制，那么就很难像抢占式调度那样做到强制的 CPU 控制权切换到其他进程&#x2F;线程，通常只能进行 协作式调度，需要协程自己主动把控制权转让出去之后，其他协程才能被执行到。内存消耗方面每个 goroutine (协程) 默认占用内存远比 Java 、C 的线程少。goroutine：2KB（官方）线程：8MB（参考网络）线程和 goroutine 切换调度开销方面线程&#x2F;goroutine 切换开销方面，goroutine 远比线程小线程：涉及模式切换(从用户态切换到内核态)、16个寄存器、PC、SP...等寄存器的刷新等。goroutine：只有三个寄存器的值修改 - PC &#x2F; SP &#x2F; DX. Go 语言对测试函数的名称和签名都有哪些规定？123对于功能测试函数来说，其名称必须以Test为前缀，并且参数列表中只应有一个*testing.T类型的参数声明。对于性能测试函数来说，其名称必须以Benchmark为前缀，并且唯一参数的类型必须是*testing.B类型的。对于示例测试函数来说，其名称必须以Example为前缀，但对函数的参数列表没有强制规定。 go的性能分析123456runtime&#x2F;pprof；net&#x2F;http&#x2F;pprof；runtime&#x2F;trace；$ go tool pprof cpuprofile.outType: cpuTime: Nov 9, 2018 at 4:31pm (CST)Duration: 7.96s, Total samples &#x3D; 6.88s (86.38%)Entering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)(pprof)","tags":[{"name":"golang","slug":"golang","permalink":"http://lcf12307.github.io/tags/golang/"}]},{"title":"【第一课】消息队列","date":"2020-03-17T08:14:00.000Z","path":"2020/03/17/面试/要点整理/消息队列/","text":"消息队列的使用场景1231. 解耦2. 异步3. 削峰 怎么保证消息不会丢失1保证消息的幂等性 推和拉模式分别有什么优势和劣势12345678910111213Push方式：优点：有消息就推给消费者。延迟小,几乎可以做到实时。等等。。。。缺点：Server端接收到消息后，主动把消息推送给Client端，实时性高。对于一个提供队列服务的Server来说，用Push方式主动推送有很多弊端；首先是加大Server端的工作量，进而影响Server的性能，其次Client的处理能力各不相同，Client的状态不受Server控制，如果Client不能及时处理Server推送过来的消息，会造成各种潜在问题。菠萝科技注：意思是1 加大server(broker)工作量,影响性能。2 有的消费者机器配置好处理能力强,有的配置低处理能力低,但是server推相同数量级消息给消费者，就会导致消费者强的等待,弱的处理效率跟不上,从而导致崩溃。3server资源相比消费者的资源肯定是更宝贵 4总结下就是客户端慢消费(设计到io等耗时操作)时会放大缺点。Pull方式：优点：对比push优点就是消费者可以根据自己能力拉取消息处理。。。缺点：Client端循环地从Server端拉取消息，主动权在Client手里，自己拉取到一定量消息后，处理妥当了再接着取。Pull方式的问题是循环拉取消息的间隔不好设定，间隔太短就处在一个“忙等”的状态，浪费资源；每个Pull的时间间隔太长，Server端有消息到来有可能没有被及时处理。菠萝科技注：假如处理完消息后，现在空闲，设定多久去server再拉消息？主要问题就是消息处理延迟忙等。server没消息时,但是消费者因为是定时去pull，导致空pull。 设计一个消息队列1231.Producer(消息生产者)：发送消息到Broker。2.Broker(服务端)：Broker这个概念主要来自于Apache的ActiveMQ，特指消息队列的服务端。主要功能就是：把消息从发送端传送到接收端，这里会涉及到消息的存储、消息通讯机制等。3.Consumer(消息消费者)：从消息队列接收消息，consumer回复消费确认。 12345678910111213141516为了实现上述消息队列的基础功能：1）消息的传输2）存储3）消费就需要涉及到如下三个方面的设计：1）通信协议 统一格式2）存储选择 速度来看，文件系统&gt;分布式KV（持久化）&gt;分布式文件系统&gt;数据库，而可靠性却截然相反。3）消费关系维护 单播，就是点到点；而广播，是一点对多点。消息的顺序投递可靠性保证消息持久化支持不同消息模型多实例集群功能事务特性等 rabbit MQ1234567891011121314151617181920212223242526272829由Erlang语言开发，继承其天生的并发性，稳定性和安全性有保障协议： AMQP（Advanced Message Queuing Protocol）高级消息队列协议，是一个异步消息传递所使用应用层协议规范，Server : 又称Broker, 接受客户端连接, 实现AMQP实体服务Connection : 连接, 应用程序与Broker的网络连接Channel : 网络信道, 几乎所有的操作都在Channel中进行, Channel是进行消息读写的通道。客户端可以建立多个Channel, 每个Channel代表一个会话任务。Message : 消息, 服务器和应用程序之间传送的数据, 有Properties和Body组成。Properties可以对消息进行修饰, 比如消息的优先级, 延迟等高级特性; Body就是消息体内容。Virtual Host : 虚拟地址, 用于进行逻辑隔离, 最上层的消息路由。一个Virtual Host里面可以有若干个Exchange和Queue, 同一个Virtual Host里面不能有相同名称的Exchange或QueueExchange : 交换机, 用于接收消息, 根据路由键转发消息到绑定的队列Binding : Exchange和Queue之间的虚拟连接, binding中可以包含routing keyRouting Key : 一个路由规则, 虚拟机可用它来确定如何路由一个特定消息Queue : 也成Message Queue, 消息队列, 用于保存消息并将它们转发给消费者消息的可靠性传递或回退重试机制和幂等性保障自动确认与手动确认RabbitMQ提供了一种qos(服务质量保证)功能, 即在非自动确认消息的前提下, 如果一定数目的消息(通过consumer或者channel设置qos的值)未被确认前, 不进行消费新的消息消息落库, 对消息状态进行标记消息的延迟投递, 做二次确认, 回调检查step1:消息入库step2:消息发送step3:消费端消息确认step4:更新库中消息状态为已确认step5:定时任务读取数据库中未确认的消息step6:未收到确认结果的消息重新发送step7:如果重试几次之后仍然失败, 则将消息状态更改为投递失败的终态, 后面需要人工介入","tags":[{"name":"数据库","slug":"数据库","permalink":"http://lcf12307.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MYSQL","slug":"MYSQL","permalink":"http://lcf12307.github.io/tags/MYSQL/"}]},{"title":"【面试复盘】腾讯面试","date":"2020-03-13T16:00:00.000Z","path":"2020/03/14/面试/复盘/3.14腾讯面试/","text":"redis 常用数据类型redis的删除机制mysql 查询数据量较大的时候cap","tags":[{"name":"复盘","slug":"复盘","permalink":"http://lcf12307.github.io/tags/%E5%A4%8D%E7%9B%98/"}]},{"title":"【面试复盘】腾讯面试","date":"2020-03-12T16:00:00.000Z","path":"2020/03/13/面试/复盘/3.13腾讯面试/","text":"1234567891011121314151617&#x2F;&#x2F;where a&#x3D;1 and b&#x3D;2 and c&#x3D;3 &#x2F;&#x2F;where a&#x3D;1 and b&lt;2 and c&#x3D;3 &#x2F;&#x2F;where a&lt;2 and b&#x3D;2 &#x2F;&#x2F;where b&#x3D;1 and c&#x3D;2 &#x2F;&#x2F;where a&#x3D;1 and b&#x3D;2 order by c&lt;3 &#x2F;&#x2F;var funcList []func() &#x2F;&#x2F;for i :&#x3D; 0; i &lt; 3; i++ &#123; &#x2F;&#x2F; funcList &#x3D; append(funcList, func() &#123; &#x2F;&#x2F; println(i) &#x2F;&#x2F; &#125;) &#x2F;&#x2F; &#x2F;&#x2F;&#125; &#x2F;&#x2F; &#x2F;&#x2F;for j :&#x3D; 0; j &lt; 3; j++ &#123; &#x2F;&#x2F; funcList[j]() &#x2F;&#x2F;&#125; 消息队列推拉分别的利弊12345678910111213141516Push方式：优点：有消息就推给消费者。延迟小,几乎可以做到实时。等等。。。。缺点：Server端接收到消息后，主动把消息推送给Client端，实时性高。对于一个提供队列服务的Server来说，用Push方式主动推送有很多弊端；首先是加大Server端的工作量，进而影响Server的性能，其次Client的处理能力各不相同，Client的状态不受Server控制，如果Client不能及时处理Server推送过来的消息，会造成各种潜在问题。菠萝科技注：意思是1 加大server(broker)工作量,影响性能。2 有的消费者机器配置好处理能力强,有的配置低处理能力低,但是server推相同数量级消息给消费者，就会导致消费者强的等待,弱的处理效率跟不上,从而导致崩溃。3server资源相比消费者的资源肯定是更宝贵 4总结下就是客户端慢消费(设计到io等耗时操作)时会放大缺点。Pull方式：优点：对比push优点就是消费者可以根据自己能力拉取消息处理。。。缺点：Client端循环地从Server端拉取消息，主动权在Client手里，自己拉取到一定量消息后，处理妥当了再接着取。Pull方式的问题是循环拉取消息的间隔不好设定，间隔太短就处在一个“忙等”的状态，浪费资源；每个Pull的时间间隔太长，Server端有消息到来有可能没有被及时处理。菠萝科技注：假如处理完消息后，现在空闲，设定多久去server再拉消息？主要问题就是消息处理延迟忙等。server没消息时,但是消费者因为是定时去pull，导致空pull。长轮询：CMQ (腾讯)提供了长轮询的优化方法，用以平衡 Pull&#x2F;Push 模型各自的缺点。 nginxGolang 在 runtime、系统调用等多方面对 goroutine 调度进行了封装和处理，当遇到长时间执行或者进行系统调用时，会主动把当前 goroutine 的CPU (P) 转让出去，让其他 goroutine 能被调度并执行，也就是 Golang 从语言层面支持了协程。redis clusterCodis 需要通过 Proxy 来定位目标节点，RedisCluster 是直接定位。客户端为了可以直接定位某个具体的 key 所在的节点，它就需要缓存槽位相关信息，这样才可以准确快速地定位到相应的节点。同时因为槽位的信息可能会存在客户端与服务器不一致的情况，还需要纠正机制来实现槽位信息的校验调整。 Cluster 默认会对 key 值使用 crc16 算法进行 hash 得到一个整数值，然后用这个整数值对 16384 进行取模来得到具体槽位。 线程 进程和携程12345678910111213协程是一种用户态的轻量级线程，协程的调度完全由用户控制（进程和线程都是由cpu 内核进行调度）。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。对于 进程、线程，都是有内核进行调度，有 CPU 时间片的概念，进行 抢占式调度（有多种调度算法）对于 协程(用户级线程)，这是对内核透明的，也就是系统并不知道有协程的存在，是完全由用户自己的程序进行调度的，因为是由用户程序自己控制，那么就很难像抢占式调度那样做到强制的 CPU 控制权切换到其他进程&#x2F;线程，通常只能进行 协作式调度，需要协程自己主动把控制权转让出去之后，其他协程才能被执行到。内存消耗方面每个 goroutine (协程) 默认占用内存远比 Java 、C 的线程少。goroutine：2KB（官方）线程：8MB（参考网络）线程和 goroutine 切换调度开销方面线程&#x2F;goroutine 切换开销方面，goroutine 远比线程小线程：涉及模式切换(从用户态切换到内核态)、16个寄存器、PC、SP...等寄存器的刷新等。goroutine：只有三个寄存器的值修改 - PC &#x2F; SP &#x2F; DX.","tags":[{"name":"复盘","slug":"复盘","permalink":"http://lcf12307.github.io/tags/%E5%A4%8D%E7%9B%98/"}]},{"title":"【面试复盘】头条面试","date":"2020-03-11T16:00:00.000Z","path":"2020/03/12/面试/复盘/3.12头条面试/","text":"redis 主从同步判断是否是一个完全二叉树消息队列 推和拉的优劣","tags":[{"name":"复盘","slug":"复盘","permalink":"http://lcf12307.github.io/tags/%E5%A4%8D%E7%9B%98/"}]},{"title":"【面试复盘】腾讯面试","date":"2020-03-09T16:00:00.000Z","path":"2020/03/10/面试/复盘/3.10腾讯面试/","text":"哪种索引的性能最好1索引的选择性是指，不重复的索引值（也称为基数）和数据表的记录总数（rows）的比值，范围从1&#x2F;rows到1之间。索引的选择性越高则查询效率越高，因为选择性高的索引可以让Mysql在查找时过滤掉更多的行。唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。而假如我们是按某个表的性别字段作为索引列，这样选择性就很低，索引效果就不是很明显。 什么时候用不到索引123456789以%开头的 like 查询不能利用 B-Tree 索引，执行计划中 key 的值为 null 表示没有使用索引数据类型出现隐式转换的时候也不会使用索引，例如，where &#39;age&#39; 10&#x3D;30对索引列进行函数运算，原因同上正则表达式不会使用索引字符串和数据比较不会使用索引复合索引的情况下，假如查询条件不包含索引列最左边部分，即不满足最左原则 leftmost，是不会使用复合索引的如果 MySQL 估计使用索引比全表扫描更慢，则不使用索引用 or 分割开的条件，如果 or 前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到使用负向查询（not ，not in， not like ，&lt;&gt; ,!&#x3D; ,!&gt; ,!&lt; ） 不会使用索引 redis 压缩列表 跳表aof日志量过大的时候重写，瘦身","tags":[{"name":"复盘","slug":"复盘","permalink":"http://lcf12307.github.io/tags/%E5%A4%8D%E7%9B%98/"}]},{"title":"【面试复盘】跟谁学面试","date":"2020-03-01T16:00:00.000Z","path":"2020/03/02/面试/复盘/3.2跟谁学面试/","text":"一面grpc和thrift消息队列golang append 的原理chan的底层方法interface和变量interface的区别123456具有一组方法的类型interface 变量存储的是实现者的值interface 的重要用途就体现在函数 f 的参数中，如果有多种类型实现了某个 interface，这些类型的值都可以直接使用 interface 的变量存储。interface&#123;&#125; 是一个空的 interface 类型，根据前文的定义：一个类型如果实现了一个 interface 的所有方法就说该类型实现了这个 interface，空的 interface 没有方法，所以可以认为所有的类型都实现了 interface&#123;&#125;。如果定义一个函数参数是 interface&#123;&#125; 类型，这个函数应该可以接受任何类型作为它的参数。go 可以使用 comma, ok 的形式做区分 value, ok :&#x3D; em.(T)：em 是 interface 类型的变量，T代表要断言的类型，value 是 interface 变量存储的值，ok 是 bool 类型表示是否为该断言的类型 T。 【算法题】123456789101112131415161718192021222324252627282930&#x2F;&#x2F; 合并链表func merge(a, b *ListNode) *ListNode &#123; var c *ListNode if a !&#x3D; nil &amp;&amp; b !&#x3D; nil &#123; if a.Val &gt; b.Val &#123; c, b.Next, b &#x3D; b, nil, b.Next b &#x3D; b.Next &#125; else &#123; c, a.Next, a &#x3D; a, nil, a.Next a &#x3D; a.Next &#125; &#125; if a !&#x3D; nil &#123; if c &#x3D;&#x3D; nil &#123; return a &#125; else &#123; c.Next &#x3D; a &#125; &#125; else if b !&#x3D; nil &#123; if c &#x3D;&#x3D; nil &#123; return b &#125; else &#123; c.Next &#x3D; b &#125; &#125; return c&#125; 二面消息队列幂等性http和tcp 和http2.0golang实现支持并发的单例模式1234567891011var exa *examplevar mu sync.Mutexfunc GetInstance() *example &#123; if exa != nil &#123; return exa &#125; mu.Lock() defer mu.Unlock() exa = &amp;example&#123;&#125; return exa&#125; 123456789101112type example struct &#123; name string&#125;var instance *examplevar once Sync.Oncefunc GetInstance() *example &#123; Once.Do(func()&#123; instance = &amp;example&#123;&#125; instance.name = \"test\" &#125;) return instance&#125;","tags":[{"name":"复盘","slug":"复盘","permalink":"http://lcf12307.github.io/tags/%E5%A4%8D%E7%9B%98/"}]},{"title":"【面试复盘】百度面试","date":"2020-02-29T16:00:00.000Z","path":"2020/03/01/面试/复盘/3.18百度面试/","text":"etcd和redis123数据库版本控制高可用","tags":[{"name":"复盘","slug":"复盘","permalink":"http://lcf12307.github.io/tags/%E5%A4%8D%E7%9B%98/"}]},{"title":"【面试复盘】百度面试","date":"2020-02-29T16:00:00.000Z","path":"2020/03/01/面试/复盘/3.19搜狐面试/","text":"聚簇索引和非聚簇索引的区别123聚集索引与非聚集索引的区别是：叶节点是否存放一整行记录InnoDB 主键使用的是聚簇索引，MyISAM 不管是主键索引，还是二级索引使用的都是非聚簇索引。 1234聚簇索引的优点1.当你需要取出一定范围内的数据时，用聚簇索引也比用非聚簇索引好。2.当通过聚簇索引查找目标数据时理论上比非聚簇索引要快，因为非聚簇索引定位到对应主键时还要多一次目标记录寻址,即多一次I&#x2F;O。3.使用覆盖索引扫描的查询可以直接使用页节点中的主键值。 12341.插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键。2.更新主键的代价很高，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为不可更新。3.二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。二级索引的叶节点存储的是主键值，而不是行指针（非聚簇索引存储的是指针或者说是地址），这是为了减少当出现行移动或数据页分裂时二级索引的维护工作，但会让二级索引占用更多的空间。4.采用聚簇索引插入新值比采用非聚簇索引插入新值的速度要慢很多，因为插入要保证主键不能重复，判断主键不能重复，采用的方式在不同的索引下面会有很大的性能差距，聚簇索引遍历所有的叶子节点，非聚簇索引也判断所有的叶子节点，但是聚簇索引的叶子节点除了带有主键还有记录值，记录的大小往往比主键要大的多。这样就会导致聚簇索引在判定新记录携带的主键是否重复时进行昂贵的I&#x2F;O代价。 并发和并行1234并发性(concurrency)，又称共行性，是指能处理多个同时性活动的能力，并发事件之间不一定要同一时刻发生。并行(parallelism)是指同时发生的两个并发事件，具有并发的含义，而并发则不一定并行。前者是逻辑上的同时发生（simultaneous），而后者是物理上的同时发生．","tags":[{"name":"复盘","slug":"复盘","permalink":"http://lcf12307.github.io/tags/%E5%A4%8D%E7%9B%98/"}]},{"title":"【面试复盘】头条面试","date":"2020-02-29T16:00:00.000Z","path":"2020/03/01/面试/复盘/3.1头条面试/","text":"一面具体的rpc调用过程消息队列的使用过程如果一个事务里想要操作两个不同数据库的数据，怎么操作redis 分布式锁 的使用redis 过期机制的sql：找出一个班里的哪个年龄的人最多1select age from user group by age order by count(age) desc limit 1 算法： 给定一个数组，0i单调递增，in单调递减，其中n为数组长度，i未知。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677去重后元素的个数input: [1, 3, 5, 100, 2, 1]output: 5不使用额外的空间，不改变原数组input: 1 2output: 0 4func findT(target int, arr []int) int &#123; if len(arr) == 0 &#123; return -1 &#125; l, r := 0, len(arr)-1 for l &lt;= r &#123; mid := l + (r-l)/2 if target == arr[mid] &#123; return mid &#125; d := IsD(arr, mid) if d = 1 &#123; if target &gt; arr[l] &amp;&amp; arr[mid] &gt; target &#123; r = mid - 1 &#125; else &#123; l = mid + 1 &#125; &#125; else if d == -1 &#123; if target &lt; arr[mid] &amp;&amp; arr[r] &lt; target &#123; l = mid + 1 &#125; else &#123; r = mid -1 &#125; &#125; else &#123; res := findTInArea(arr, l, mid-1, target, 1) if res != -1 &#123; return res &#125; res = findTInArea(arr, mid+1, r, target, -1 ) return res &#125; &#125; if arr[mid] == target &#123; return mid &#125; return -1&#125;// 判断是否单调 且单调的方向func IsD(arr []int, index int) int &#123; if index &gt; 0 &amp;&amp; index &lt; len(arr) - 1 &#123; if arr[index] &gt; arr[index-1] &amp;&amp; arr[index] &lt; arr[index + 1] &#123; return 1 &#125; if arr[index] &lt; arr[index-1] &amp;&amp; arr[index] &gt; arr[index + 1] &#123; return -1 &#125; &#125; if index == 0 &#123; return 1 &#125; if index == len(arr) - 1 &#123; return -1 &#125; return 0&#125;// 常规二分查找func findTInArea(arr int[], l, r , target, ty int) int&#123; if len(arr) == 0 &#123; return -1 &#125; l, r := 0, len(arr)-1 for l &lt;= r &#123; mid = l + (r-l)/2 if arr[mid] == target &#123; &#125; &#125;&#125; 二面context使用 及简单代码123456789101112131415161718192021222324252627282930func WithCancel(parent Context) (ctx Context, cancel CancelFunc)func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc)func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)func WithValue(parent Context, key, val interface&#123;&#125;) Contextfunc Background() Contextfunc main() &#123; ctx, cancel := context.WithCancel(context.Background()) go watch(ctx,\"【监控1】\") go watch(ctx,\"【监控2】\") go watch(ctx,\"【监控3】\") time.Sleep(10 * time.Second) fmt.Println(\"可以了，通知监控停止\") cancel() //为了检测监控过是否停止，如果没有监控输出，就表示停止了 time.Sleep(5 * time.Second)&#125;func watch(ctx context.Context, name string) &#123; for &#123; select &#123; case &lt;-ctx.Done(): fmt.Println(name,\"监控退出，停止了...\") return default: fmt.Println(name,\"goroutine监控中...\") time.Sleep(2 * time.Second) &#125; &#125;&#125; 实现简单的消息队列 并说出优化方向优化方向 增加消息的容量 消息存入硬盘，保证高可用 如果消费阻塞的话，另一方面，增加消费者数目 123456789101112131415161718192021222324252627282930313233343536373839404142type Producer struct &#123; messages [9]chan string&#125;type Consumer struct &#123; messages [9]chan string&#125;func (p *Producer) init(message [9]chan string) &#123; p.messages = message&#125;func (p *Producer) send(message string) &#123; p.messages &lt;- message&#125;func (c *Consumer) init (message [9]chan string) &#123; c.messages = message&#125;func (c *Receive) receive() string &#123; for &#123; switch &#123; case &lt;-c.message: return c.message default: return \"\" &#125; sleep(100) &#125;&#125;func main() &#123; message := [9]chan string var prod Producer var cons Consumer prod.init(message) cons.init(message) for i:=0; i&lt;100;i++ &#123; go func() &#123; prod.send(\"test\") &#125; &#125; s := cons.receive() fmt.Println(s)&#125; 防刷的做法时间维度和ip维度 【算法题】 k个一组 反转链表12 三面【系统设计题】设计一个抢红包的结构1234567页面-后端- 长连接 - 短链接 - 每次点击时提交 or 出完结果后提交- API- Redis- MQ -&gt; 使用mq消费，异步，削峰，解耦 【系统设计题】 设计一个唯一ID生成器 int64的数字 唯一 高并发 123雪花算法32位秒级时间戳+16位自增id+5位机器码42位毫秒级时间戳+10机器码+12bit序列号 【算法题】给定m个不重复的字符 [a, b, c, d]，以及一个长度为n的字符串tbcacbdata，问能否在这个字符串中找到一个长度为m的连续子串，使得这个子串刚好由上面m个字符组成，顺序无所谓，返回任意满足条件的一个子串的起始位置，未找到返回-1。比如上面这个例子，acbd，3123456789101112131415161718192021222324252627282930313233343536373839404142434445var location [256]int&#123;&#125;func indexOfStringNoRepeat(s string, target rune[]) int &#123; for i := range location &#123; location[i] = -1 &#125; rs := []rune(s) ma := make(map[rune]int) for i := range target &#123; ma[target] = 0 &#125; // shooted 目前已有的未重复字符 left, shooted := 0, 0 for i := 0; i&lt;len(rs); i++ &#123; // 不存在该字符 if _, ok := ma[rs[i]]; !ok &#123; before = left left = location[rs[i]] + 1 updateLocation(rs, before, left) continue &#125; // 该字符 if location[rs[i]] != -1 &#123; if location[rs[i]] &gt;= left &#123; before = left left = location[rs[i]] + 1 shooted updateLocation(rs, before, left) &#125; &#125; else &#123; shooted ++ if shooted == len(target) &#123; return left &#125; &#125; location[rs[i]] ++ &#125; return -1&#125;func updateLocations(rs []rune, l, r int) &#123; for l &lt; r &#123; location[rs[l]] = -1 l ++ &#125; return &#125;","tags":[{"name":"复盘","slug":"复盘","permalink":"http://lcf12307.github.io/tags/%E5%A4%8D%E7%9B%98/"}]},{"title":"【第一课】高频面试点","date":"2020-02-29T16:00:00.000Z","path":"2020/03/01/面试/要点整理/高频面试点/","text":"排序 二分变形 递归搜索 二叉树遍历 排序可以扩展出多种排序 如堆排序 合并排序 go的sync包和 多线程 多协程并发控制 网络编程 NIO 网络模型 高并发系统设计， API层设计 存储设计 容灾设计 数据流 模块设计","tags":[{"name":"linux","slug":"linux","permalink":"http://lcf12307.github.io/tags/linux/"}]},{"title":"【面试复盘】腾讯面试","date":"2020-02-28T16:00:00.000Z","path":"2020/02/29/面试/复盘/2.29腾讯面试/","text":"M G Pcontextgo对象的过程算法题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//【气球游戏】小Q在进行射击气球的游戏，// 如果小Q在连续T枪中打爆了所有颜色的气球，将得到一只QQ公仔作为奖励。//（每种颜色的气球至少被打爆一只）。这个游戏中有m种不同颜色的气球，编号1到m。// 小Q一共有n发子弹，然后连续开了n枪。小Q想知道在这n枪中，打爆所有颜色的气球最少用了连续几枪？// 输入描述： 第一行两个空格间隔的整数数n，m。n&amp;lt;=1000000 m&amp;lt;=2000 第二行一共n个空格间隔的整数，分别表示每一枪打中的气球的颜色,0表示没打中任何颜色的气球。// 输出描述： 一个整数表示小Q打爆所有颜色气球用的最少枪数。如果小Q无法在这n枪打爆所有颜色的气球，则输出-1var ma map[int]intfunc shootGame(n, m int, arr []int) int &#123; if n &lt; m &#123; return -1 &#125; ma = make(map[int]int) min := n+1 // t 已击中气球 s 射击数 最左数 t , s, l := 0, 0, 0 for _, k := range arr &#123; // 如果气球不存在存在 if _, ok := ma[k]; !ok || ma[k] == 0 &#123; if k != 0 &#123; t++ &#125; // 如果已击中气球的颜色 if t == m &#123; if min &gt; s &#123; min = s &#125; // 找到下一个点 ma[l] -- // 射击气球数目为0 t-- if ma[l] == 0 &amp;&amp; l != 0 &#123; t -- &#125; // 左移一位 l ++ // 射击数减yi s -- if t==m &amp;&amp; min &gt; s &#123; min = s &#125; &#125; &#125; // 给当前数目加一 // 射击数加一 ma[k] ++ s ++ &#125; if min == n+1 &#123; return -1 &#125; return min&#125;","tags":[{"name":"复盘","slug":"复盘","permalink":"http://lcf12307.github.io/tags/%E5%A4%8D%E7%9B%98/"}]},{"title":"【面试复盘】滴滴面试","date":"2020-02-27T16:00:00.000Z","path":"2020/02/28/面试/复盘/2.28滴滴面试/","text":"使用非递归去二分查找一个数1234567891011121314151617181920212223242526272829// arr []// arr [1]// arr [1,2,3]// arr [2,3,4]// 3, 9999,func findX(target int, arr []int) bool &#123; // if len(arr) == 0 &#123; return false &#125; // 左右两个节点 l, r := 0, len(arr)-1 var mid int for l &lt; r &#123; mid = l + (r-l)/2 if arr[mid] == target &#123; return true &#125; if arr[mid] &gt; target &#123; r = mid - 1 &#125; else &#123; l = mid + 1 &#125; &#125; return arr[l] == target&#125; 使用递归的方式 二分查找12345678910111213141516func findX(target int, arr []int) int &#123; return findXInArea(target, arr, 0, len(right)-1)&#125;func findXInArea(target int , arr []int, left, right int) int &#123; if left &gt; right &#123; return -1 &#125; mid := left + (right-left)/2 if arr[mid] &gt; target &#123; return findXInArea(target, arr, left, mid - 1) &#125; if arr[mid] &lt; target &#123; return findXInArea(target, arr, mid + 1, right) &#125; return mid&#125;","tags":[{"name":"复盘","slug":"复盘","permalink":"http://lcf12307.github.io/tags/%E5%A4%8D%E7%9B%98/"}]},{"title":"【面试复盘】映客面试","date":"2020-02-27T16:00:00.000Z","path":"2020/02/28/面试/复盘/2.28百度面试/","text":"秒杀过程中里的远近不同影响用户的秒杀成功 解决方案http和https和http2.0 spdyhttp1.0的缺点是安全不足和性能不足http2.0 更安全的http， 更快的https 二进制传输（解析更高效） header压缩 spdy 多路复用 服务器端推送 提高安全性 - 队头阻塞 - TCP+TLS延时QUIChttps对称加密和非对称加密 负载均衡http2.0 有哪些优化的方向解决队头阻塞的问题 gopath goroot gobin都是什么命令行实现查找日志文件中的qps1cat access.log | awk '&#123;print $2&#125;' | uniq -c 两个链表 求他们是否有公共节点 并求出他们的交点位置1234// 求尾部唯一// 连接ab 判断存在环","tags":[{"name":"复盘","slug":"复盘","permalink":"http://lcf12307.github.io/tags/%E5%A4%8D%E7%9B%98/"}]},{"title":"【面试复盘】映客面试","date":"2020-02-26T16:00:00.000Z","path":"2020/02/27/面试/复盘/2.27映客面试/","text":"访问mi.com 的过程rpc的协议除了pb http怎么返回数据ASCII码 怎么保证消息队列不会重复处理唯一keyid mysql调优 的方法使用redis来实现定时器 如果所有用户等待时间相同 或者不同 list rpush lpop zset zrangebyscore key min max mysql 主库写入还没有更新到读库的时候 怎么保证读的数据是最新的","tags":[{"name":"复盘","slug":"复盘","permalink":"http://lcf12307.github.io/tags/%E5%A4%8D%E7%9B%98/"}]},{"title":"【面试复盘】滴滴面试","date":"2020-02-26T16:00:00.000Z","path":"2020/02/27/面试/复盘/2.27滴滴面试/","text":"二叉树最长叶子结点路径之和12345678910111213type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125;func longestWaySum(root *TreeNode) &#123; &#125;func dfs(root *TreeNode, level, before int) (depth, sum int) &#123; &#125; 大文件如何对字符串计数数据库的四种隔离级别 并举例说明mysql的非sql命令binlog的格式binlog分为三种格式 statement 用来记录每一条修改的语句 Row 不记录具体的语句 只记录哪条记录被修改 缺点 有些语句修改量过大， 记录不了 Mixedlevel 混合使用，仅特殊语句 会记录 如sleep()函数， last_insert_id()，以及user-defined functions(udf 为什么使用b+树hash：虽然可以快速定位，但是没有顺序，IO复杂度高。 二叉树：树的高度不均匀，不能自平衡，查找效率跟数据有关（树的高度），并且IO代价高。 红黑树：树的高度随着数据量增加而增加，IO代价高。 为什么树的高度影响IO代价尽管内存上读取速度快， 但是会可能因为断电等原因造成数据丢失，存在硬盘上可以保证数据的持久化，而每个数据节点代表一个磁盘块。 b+树范围查询有序的链表 为什么使用连续自增主键结合B+Tree的特点，自增主键是连续的，在插入过程中尽量减少页分裂，即使要进行页分裂，也只会分裂很少一部分。并且能减少数据的移动，每次插入都是插入到最后。总之就是减少分裂和移动的频率 统计日志的qps123456789# 实时统计## 方式一tail -f access.log | awk -F '[' '&#123;print $2&#125;' | awk 'BEGIN&#123;key=\"\";count=0&#125;&#123;if(key==$1)&#123;count++&#125;else&#123;printf(\"%s\\t%d\\r\\n\", key, count);count=1;key=$1&#125;&#125;' ## 方式二tail -f access.log | awk -F '[' '&#123;print $2&#125;' | awk '&#123;print $1&#125;' | uniq -c # 非实时按秒统计QPScat access.log | awk -F '[' '&#123;print $2&#125;' | awk '&#123;print $1&#125;' | sort | uniq -c |sort -k1,1nr http四种方法 以及header头里会携带什么参数 put get post delete head … head头参数 reffer accept cookie Host User-agent 请求报文包括 请求行 请求头 空行 请求体 状态码 200 301 302 500 404 下载文件访问mi.com的过程url缓存 浏览器进行安全检查和访问控制 dns查询 检查浏览器缓存 检查host文件 路由器缓存 首选dns解析服务器 根域名服务器查询 tcp连接 应用层 发送网络请求 传输层 TCP传输报文 网络层 ip查询mac地址 链路层 以太网协议 到达服务器时反转上述操作","tags":[{"name":"复盘","slug":"复盘","permalink":"http://lcf12307.github.io/tags/%E5%A4%8D%E7%9B%98/"}]},{"title":"【面试复盘】映客面试","date":"2020-02-26T16:00:00.000Z","path":"2020/02/27/面试/复盘/2.27知乎面试/","text":"raft的应用场景 同类的算法Etched hash的时候一个节点链表过长怎么处理 更换算法 更换数据结构 redis持久化AOF RDB b+树在保存唯一索引的时候的生成mysql 读到从库未更新数据 如何解决 主从使用一个数据库 （pass） 写完库后更新缓存 设置过期时间 使用数据库中间件 golang里 make 和 a := []int{} 的区别归并排序的时间复杂度和空间复杂度（空间复杂度的计算）排序算法比较表格 排序算法 平均时间复杂度 最坏时间复杂度 空间复杂度 是否稳定 冒泡排序 o(n2) o(n2) o(1) 是 |选择排序 |O（n2）|O（n2）| O（n2）|O（n2）| O（1）|O（1） |不是||直接插入排序| O（n2）|O（n2）| O（n2）|O（n2）| O（1）|O（1） |是||归并排序| O(nlogn)|O(nlogn) |O(nlogn)|O(nlogn) |O（n）|O（n）| 是||快速排序 |O(nlogn)|O(nlogn)| O（n2）|O（n2）| O（logn）|O（logn）| 不是||堆排序 |O(nlogn)|O(nlogn)| O(nlogn)|O(nlogn) |O（1）|O（1） |不是||希尔排序| O(nlogn|)O(nlogn)| O（ns）|O（ns）| O（1）|O（1）| 不是||计数排序| O(n+k)|O(n+k)| O(n+k)|O(n+k)| O(n+k)|O(n+k) 是||基数排序| O(N∗M|)O(N∗M)| O(N∗M)|O(N∗M) |O(M)|O(M) |是| n个有序数组 合并dns使用的协议Udp协议 内网ip访问到公网ip的路径内网ip在局域网内是唯一的， 但是可以通过该局域网对应的公网ip来实现对其他公网IP的访问","tags":[{"name":"复盘","slug":"复盘","permalink":"http://lcf12307.github.io/tags/%E5%A4%8D%E7%9B%98/"}]},{"title":"【面试复盘】作业帮面试","date":"2020-02-24T16:00:00.000Z","path":"2020/02/25/面试/复盘/2.25作业帮面试/","text":"小结1作业帮的面试相对会问很多业务相关的东西， 并且会有很多mysql的代码提问 一面在数据库主库和从库不一致的时候，怎么保证数据正确 读写都在主库 在写入sql的时候，同时更新缓存，过期时间可以根据自己的经验设置 数据库中间件 （成本较高）读取走读库， 写走写库， 判断如果这个key最近修改过， 也走写库 怎么保证数据库和redis数据一致性 延时双删 超时时间内还是会有问题 异步更新 binlog增量订阅 + 消息队列 + 更新redis rabbitMQ比redis作为消息队列的优点mysql的锁的类型事务隔离的级别12345数据库提供的四种隔离级别：01：Read uncommitted(读未提交)：最低级别，任何情况都会发生。02：Read Committed(读已提交)：可避免脏读的发生。03：Repeatable read(可重复读)：可避免脏读、不可重复读的发生。04：Serializable(串行化)：避免脏读、不可重复读，幻读的发生。 下面代码关键字的执行顺序1select * from tables where true order by id limit 1 怎么保证增减积分的时候不会多扣 消息队列 设锁（悲观锁） where git cherry-pick反向代理二面rabbitMQ是一种怎么样的形式， 推还是订阅联合索引的执行顺序最左匹配原则 为什么要使用联合索引 减少开销 建一个联合索引等于建很多索引 like能否用索引 !=呢 in呢 like的前模糊和全模糊不会走索引 即 %j j j 或%j j j% 使用&lt;&gt; 或者 != 也不走索引 in走索引 分段有序的数组， 查找指定数123456789101112131415161718192021222324// 二分法func findX(x int, a []int) bool &#123; l, r := 0, len(a)-1 for l &lt; r &#123; mid = l + (r-l)/2 if a[mid] == x &#123; return true &#125; if a[mid-1] &gt; a[l] &#123; if a[mid - 1] &gt; x &amp;&amp; x &gt; a[l] &#123; r= mid -1 &#125; else &#123; l = mid + 1 &#125; &#125; else &#123; if a[mid+1] &lt; x &amp;&amp; x &lt; a[r] &#123; l = mid + 1 &#125; else &#123; r = mid - 1 &#125; &#125; &#125;&#125;","tags":[{"name":"复盘","slug":"复盘","permalink":"http://lcf12307.github.io/tags/%E5%A4%8D%E7%9B%98/"}]},{"title":"【面试复盘】来也面试","date":"2020-02-24T16:00:00.000Z","path":"2020/02/25/面试/复盘/2.25来也面试/","text":"该部门只是对一个微信公众号的网站进行维护 因此兴趣不大 基础并列排行榜的实现使用浮点数 如果分数是整数的时候，直接大于x.1即可 hash的底层实现 数组加链表的数据结构 通过算法计算hash_code （可能会有hash冲突） hash冲突的时候使用链表 评论的时候怎么保证幂等性mysql 线上有1000万个数据，怎么加索引新建另外的数据库来加 mysql 1000万个数据，怎么分页加一个子查询 id&gt;= limit 1select * from test where id &gt;= (select id from test limit 9000000,1)limit 0,100 grpc的底层协议grpc底层使用的是http2.0 传输的数据结构是protocolbuf 是二进制的格式","tags":[{"name":"复盘","slug":"复盘","permalink":"http://lcf12307.github.io/tags/%E5%A4%8D%E7%9B%98/"}]},{"title":"【面试复盘】来也面试","date":"2020-02-24T16:00:00.000Z","path":"2020/02/25/面试/复盘/2.26好未来面试/","text":"这个部门的面试好水啊…. 主要业务 小猴语文 基础redis的数据类型redis中的string和c中的string相似， 因为c里的string时字符数组的格式， 而c++里的是一个指针加上长度 rabbitMQ和talos的模式 是推还是拉grpc和thrift的区别算法逐行遍历数， 求列数1// dfs 数组里 找重复元素12// 1. hash// 2. 排序 二面mvcclru数据库千万级为什么会慢请求一个连接的访问过程go的热加载实现","tags":[{"name":"复盘","slug":"复盘","permalink":"http://lcf12307.github.io/tags/%E5%A4%8D%E7%9B%98/"}]},{"title":"【面试复盘】滴滴面试","date":"2020-02-24T16:00:00.000Z","path":"2020/02/25/面试/复盘/2.26滴滴面试/","text":"滴滴一面老哥人比较好，会帮忙思考一些问题 基础发现cpu异常，应该如何处理go程序有没有办法使用工具检测还有一个go自己的工具 go tool trace, 它有一个UI, 允许你查看你的程序和运行时的状况 linux 干掉占用内存过高的程序 Top &amp;&amp; sudo kill -9 pid Pid 的ppid有可能还没被杀死 -9 表示强制的参数 mysql有什么分库分表的中间件go的context上下文 主要是对协程进行统一管理 context包中还包含了四个用于繁衍Context值的函数，即：WithCancel、WithDeadline、WithTimeout和WithValue。 go的协程与线程的区别协程 协程由一个或者多个线程管理， 且协程调度发生在线程中 可以被调度，调度策略由应用层代码实现 高效， 节省了线程切换的成本 占用内存少 线程的内存供多个goroutine使用 锁和channel的区别go的mutex是否是可重入锁go的mutex是不是公平锁测试包的使用对于功能测试函数来说，其名称必须以Test为前缀，并且参数列表中只应有一个testing.T类型的参数声明。 对于性能测试函数来说，其名称必须以Benchmark为前缀，并且唯一参数的类型必须是*testing.B类型的。 对于示例测试函数来说，其名称必须以Example为前缀，但对函数的参数列表没有强制规定。 MPG快排的稳定性为什么差因为每次都随机选择快排子 优化快排多列索引的实现q rabbitMQ底层怎么做存储waitGroup的缺点","tags":[{"name":"复盘","slug":"复盘","permalink":"http://lcf12307.github.io/tags/%E5%A4%8D%E7%9B%98/"}]},{"title":"【面试复盘】伴鱼面试","date":"2020-02-23T16:00:00.000Z","path":"2020/02/24/面试/复盘/2.24伴鱼面试/","text":"算法题1234567891011121314151617181920212223242526272829303132333435363738394041// 用一个 M×N 的矩阵表示一个未知星球的地表，0 表示该区域为海洋，1 表示该区域为陆地，每块陆地只可能与上、下、左、右相邻的四块陆地接壤，请找到这个星球上面积最大的岛屿。// 示例：// 输入：// [// [1, 1, 0],// [1, 0, 0],// [0, 0, 1]// ]// 输出：3func maxArea(grid [][]int) int &#123; max := 0 for i:=0; i&lt;len(grid); i++ &#123; for j:=0; j&lt; len(grid[0]; j++) &#123; if grid[i][j] == 1 &#123; area := dfs(grid, i, j) if area &gt; max &#123; max = area &#125; &#125; &#125; &#125; return max&#125;func dfs(grid [][]int, x,y int) int &#123; if x &lt; 0 || x &gt;= len(grid) || y &lt; 0 || y &gt;= len(grid[0]) &#123; return 0 &#125; if grid[i][j] == 0 &#123; return 0 &#125; area := 1 grid[i][j] == 0 dx := [4]int&#123;0,0,-1,1&#125; dy := [4]int&#123;-1, 1, 0, 0&#125; for i := 0; i&lt; 4; i++ &#123; area += dfs(grid, x+ dx[i], y + dy[i]) &#125; return area&#125; 基础Go 变量与函数同名有n个大文件，无法加载进内存， 里面内容是无序的，怎么把他们合并成一个有序的文件外排序 建堆的过程123456大顶堆：每个结点的值都大于或等于其左右孩子结点的值小顶堆：每个结点的值都小于或等于其左右孩子结点的值根据堆的特性来形成公式就是，节点为i的话大顶堆: arr[i]&gt;&#x3D;arr[2i+1] &amp;&amp; arr[i]&gt;&#x3D;arr[2i+2]小顶堆：arr[i]&lt;&#x3D;arr[2i+1] &amp;&amp; arr[i]&lt;&#x3D;arr[2i+2] 索引为什么不用b+树和平衡二叉树索引的节点 多大比较合适索引存什么样的格式比较合适树转数组 操作系统 io的大小 分页 分段 段页式 操作系统32位和64位的区别mysql执行事务的时候宕机了，恢复之后还能正常执行吗多个进程的时候，如果系统使用时间片轮转的方式 他们是用什么方式提醒下一个进程的，需要存储什么数据121. 使用中断2. 寄存器内的数据，当前任务的状态 更新数据库和缓存的时候怎么保证强一致性","tags":[{"name":"复盘","slug":"复盘","permalink":"http://lcf12307.github.io/tags/%E5%A4%8D%E7%9B%98/"}]},{"title":"【面试复盘】映客面试","date":"2020-02-23T16:00:00.000Z","path":"2020/02/24/面试/复盘/2.24映客面试/","text":"算法树的前中后序遍历12 2/ \\ 判断链表中有环1234// 使用快慢链表func cycleExist(root *ListNode) bool &#123; &#125; 爬楼梯 112// 一次可以走一步或者两步 求到第n个楼梯的方法// 斐波那契数列 爬楼梯 212// 一次可以走1-n步 求走到第n个楼梯的方法// 2的n-1次方 从左上角到右下角的方法1234567// ___________// |s| | | | |// ___________// | | | | | |// ___________// | | | | |e|// 从s点到e点有多少种方法 top k个数1234// 给定一个数组中的数 求前k个数// 方法一 暴力排序法// 方法二 中间容量为k的数组 用来存储 每次最小的出堆。最小堆// 方法三 每次选一个数将数组分为两个 基础知识mysql group by的用法1select value, count(*) from test group by value 索引的类型 聚合索引 普通索引 唯一索引 主键索引 引擎分类 myisam innodb 区别 innodb支持事务 获取总量的时候myisam比较快 innodb支持外键 索引的数据结构不一样 innodb是 b+树 myisam是b树 innodb为什么使用b + 树 数据结构更精简 为什么不用红黑树 二叉树 存储的数据量太少了 ，导致磁盘io次数增加 b+树可以范围查询 raft协议redisredis的数据结构12345stringlisthashsetzset redis怎么实现持久化的1234AOF 1s 日志 热存储RDB 快照 冷存储结合使用 zset怎么实现的1使用字典和跳表实现的 消息队列为什么使用消息队列12345解耦异步削峰","tags":[{"name":"复盘","slug":"复盘","permalink":"http://lcf12307.github.io/tags/%E5%A4%8D%E7%9B%98/"}]},{"title":"【面试复盘】知乎面试","date":"2020-02-23T16:00:00.000Z","path":"2020/02/24/面试/复盘/2.24知乎面试/","text":"知乎这个岗位不合适，是做存储系统的。 业务算法反转链表1234567891011121314type ListNode struct &#123; Val int Next *ListNode&#125;func reverseListNode(root *ListNode) root &#123; if root == nil ||root.Next == nil &#123; return root &#125; var prev *List for root != nil &#123; prev, root, root.Next = root, root.Next, prev &#125; return prev&#125;","tags":[{"name":"复盘","slug":"复盘","permalink":"http://lcf12307.github.io/tags/%E5%A4%8D%E7%9B%98/"}]},{"title":"【位运算】位一的个数","date":"2020-02-10T16:00:00.000Z","path":"2020/02/11/刷题心得/位运算/位一的个数/","text":"题目编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。 123456789101112131415示例 1：输入：00000000000000000000000000001011输出：3解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#39;1&#39;。示例 2：输入：00000000000000000000000010000000输出：1解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &#39;1&#39;。示例 3：输入：11111111111111111111111111111101输出：31解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &#39;1&#39;。 提示： 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。 代码123456789101112func hammingWeight(num uint32) int &#123; var count int for num != 0 &#123; count ++ num = num &amp; (num -1) &#125; return count&#125;func hammingWeight(num uint32) int &#123; &#125; 解题思路x = x &gt;&gt; 1 x = x % 2x &amp; (x-1) 去掉最后一个1","tags":[{"name":"算法","slug":"算法","permalink":"http://lcf12307.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"位运算","slug":"位运算","permalink":"http://lcf12307.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"}]},{"title":"【位运算】比特位计数","date":"2020-02-10T16:00:00.000Z","path":"2020/02/11/刷题心得/位运算/比特位计数/","text":"题目给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。 123456789示例 1:输入: 2输出: [0,1,1]示例 2:输入: 5输出: [0,1,1,2,1,2]进阶: 给出时间复杂度为O(n*sizeof(integer))的解答非常容易。但你可以在线性时间O(n)内用一趟扫描做到吗？要求算法的空间复杂度为O(n)。你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 __builtin_popcount）来执行此操作。 代码1234567func countBits(num int) []int &#123; res := make([]int, num + 1) for i := 1; i&lt;num+1; i ++ &#123; res[i] += res[i&amp;(i-1)] + 1 &#125; return res&#125; 解题思路","tags":[{"name":"算法","slug":"算法","permalink":"http://lcf12307.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"位运算","slug":"位运算","permalink":"http://lcf12307.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"}]},{"title":"【位运算】2的幂","date":"2020-02-10T16:00:00.000Z","path":"2020/02/11/刷题心得/位运算/2的幂/","text":"题目给定一个整数，编写一个函数来判断它是否是 2 的幂次方。 1234567891011121314示例 1:输入: 1输出: true解释: 20 &#x3D; 1示例 2:输入: 16输出: true解释: 24 &#x3D; 16示例 3:输入: 218输出: false 代码123456func isPowerOfTwo(n int) bool &#123; if n == 0 &#123; return true &#125; return n &amp; (n-1) == 0 &#125; 解题思路modlog2 = int####位运算 n&amp;(n-1)","tags":[{"name":"算法","slug":"算法","permalink":"http://lcf12307.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"位运算","slug":"位运算","permalink":"http://lcf12307.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"}]},{"title":"【二分法】求平方根","date":"2020-02-10T16:00:00.000Z","path":"2020/02/11/刷题心得/二分法/求平方根/","text":"题目给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以假设数组中无重复元素。 12345678910111213141516示例 1:输入: [1,3,5,6], 5输出: 2示例 2:输入: [1,3,5,6], 2输出: 1示例 3:输入: [1,3,5,6], 7输出: 4示例 4:输入: [1,3,5,6], 0输出: 0 代码1234567891011121314151617181920212223func searchInsert(nums []int, target int) int &#123; if len(nums) == 0 &#123; return 0 &#125; l,r := 0,len(nums)-1 if nums[r] &lt; target &#123; return r + 1 &#125; for l &lt; r &#123; mid := (l + r) / 2 if target == nums[mid] &#123; return mid &#125; if target &lt; nums[mid] &#123; r = mid &#125; if target &gt; nums[mid] &#123; l = mid + 1 &#125; &#125; return l&#125; 1234567891011121314151617func searchInsert(nums []int, target int) int &#123; // 没有把i放入for语句中 // 是为了兼容，len(nums) == 0 和 target &gt; nums[len(nums)-1]两种情况 i := 0 for i &lt; len(nums) &amp;&amp; nums[i] &lt;= target &#123; // 相等的时候，直接返回 if nums[i] == target &#123; return i &#125; // 否则，就去检查下一个 i++ &#125; return i&#125; 解题思路","tags":[{"name":"算法","slug":"算法","permalink":"http://lcf12307.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"二分法","slug":"二分法","permalink":"http://lcf12307.github.io/tags/%E4%BA%8C%E5%88%86%E6%B3%95/"}]},{"title":"【剪枝】n皇后","date":"2020-02-09T16:00:00.000Z","path":"2020/02/10/刷题心得/剪枝/n皇后/","text":"题目n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 上图为 8 皇后问题的一种解法。 给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。 每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。 示例: 12345678910111213输入: 4输出: [ [&quot;.Q..&quot;, &#x2F;&#x2F; 解法 1 &quot;...Q&quot;, &quot;Q...&quot;, &quot;..Q.&quot;], [&quot;..Q.&quot;, &#x2F;&#x2F; 解法 2 &quot;Q...&quot;, &quot;...Q&quot;, &quot;.Q..&quot;]]解释: 4 皇后问题存在两个不同的解法。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970unc solveNQueens(n int) [][]string &#123; if n == 0 &#123; return [][]string&#123;&#125; &#125; cols := make([]bool, n) // 记录 '\\' 方向的对角线的占用情况 d1 := make([]bool, 2*n) // 记录 '/' 方向的对角线的占用情况 d2 := make([]bool, 2*n) board := make([]string, n) res := [][]string&#123;&#125; dfs(0, cols, d1, d2, board, &amp;res) return res&#125;func dfs(r int, cols, d1, d2 []bool, board []string, res *[][]string) &#123; if r == len(board) &#123; tmp := make([]string, len(board)) copy(tmp, board) *res = append(*res, tmp) return &#125; n := len(board) for c := 0; c &lt; len(board); c++ &#123; // 把棋盘想象成 // 以左上角为坐标原点 [0,0] // C 轴正方向向右 // R 轴正方向向下 // 的坐标系。 // 这样的话，每个格子就都有了自己的坐标值 [c,r] // // 对于 '\\' 方向的斜线而言 // 同一个斜线上的格子，利用其坐标 [c,r] 计算 r-c 的结果相同， // 不同斜线上 r-c 的结果不同。 // 所以可以用 r-c 代表不同的 '\\' 方向的斜线的编号。 // 但是 r-c 有可能是负值，无法作为切片的索引值 // 所以 +n，可知 r-c+n &gt;= 0 // 所以，使用 r-c+n 作为 '\\' 方向斜线切片的索引值。 // 对于 '/' 方向的斜线而言 // 同一个斜线上的格子，利用其坐标 [c,r] 计算 r+c 的结果相同， // 不同斜线上 r+c 的结果不同。 // 所以可以用 r+c 代表不同的 '/' 方向的斜线的编号。 // 所以，使用 r+c 作为 '/' 方向斜线切片的索引值。 id1 := r - c + n id2 := r + c if !cols[c] &amp;&amp; !d1[id1] &amp;&amp; !d2[id2] &#123; b := make([]byte, n) for i := range b &#123; b[i] = '.' &#125; b[c] = 'Q' board[r] = string(b) // 标记占用 cols[c], d1[id1], d2[id2] = true, true, true dfs(r+1, cols, d1, d2, board, res) // 解除标记 cols[c], d1[id1], d2[id2] = false, false, false &#125; &#125;&#125; 解题思路","tags":[{"name":"算法","slug":"算法","permalink":"http://lcf12307.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"剪枝","slug":"剪枝","permalink":"http://lcf12307.github.io/tags/%E5%89%AA%E6%9E%9D/"}]},{"title":"【剪枝】n皇后","date":"2020-02-09T16:00:00.000Z","path":"2020/02/10/刷题心得/剪枝/n皇后2/","text":"题目n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 上图为 8 皇后问题的一种解法。 给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。 每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。 示例: 12345678910111213输入: 4输出: [ [&quot;.Q..&quot;, &#x2F;&#x2F; 解法 1 &quot;...Q&quot;, &quot;Q...&quot;, &quot;..Q.&quot;], [&quot;..Q.&quot;, &#x2F;&#x2F; 解法 2 &quot;Q...&quot;, &quot;...Q&quot;, &quot;.Q..&quot;]]解释: 4 皇后问题存在两个不同的解法。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970unc solveNQueens(n int) [][]string &#123; if n == 0 &#123; return [][]string&#123;&#125; &#125; cols := make([]bool, n) // 记录 '\\' 方向的对角线的占用情况 d1 := make([]bool, 2*n) // 记录 '/' 方向的对角线的占用情况 d2 := make([]bool, 2*n) board := make([]string, n) res := [][]string&#123;&#125; dfs(0, cols, d1, d2, board, &amp;res) return res&#125;func dfs(r int, cols, d1, d2 []bool, board []string, res *[][]string) &#123; if r == len(board) &#123; tmp := make([]string, len(board)) copy(tmp, board) *res = append(*res, tmp) return &#125; n := len(board) for c := 0; c &lt; len(board); c++ &#123; // 把棋盘想象成 // 以左上角为坐标原点 [0,0] // C 轴正方向向右 // R 轴正方向向下 // 的坐标系。 // 这样的话，每个格子就都有了自己的坐标值 [c,r] // // 对于 '\\' 方向的斜线而言 // 同一个斜线上的格子，利用其坐标 [c,r] 计算 r-c 的结果相同， // 不同斜线上 r-c 的结果不同。 // 所以可以用 r-c 代表不同的 '\\' 方向的斜线的编号。 // 但是 r-c 有可能是负值，无法作为切片的索引值 // 所以 +n，可知 r-c+n &gt;= 0 // 所以，使用 r-c+n 作为 '\\' 方向斜线切片的索引值。 // 对于 '/' 方向的斜线而言 // 同一个斜线上的格子，利用其坐标 [c,r] 计算 r+c 的结果相同， // 不同斜线上 r+c 的结果不同。 // 所以可以用 r+c 代表不同的 '/' 方向的斜线的编号。 // 所以，使用 r+c 作为 '/' 方向斜线切片的索引值。 id1 := r - c + n id2 := r + c if !cols[c] &amp;&amp; !d1[id1] &amp;&amp; !d2[id2] &#123; b := make([]byte, n) for i := range b &#123; b[i] = '.' &#125; b[c] = 'Q' board[r] = string(b) // 标记占用 cols[c], d1[id1], d2[id2] = true, true, true dfs(r+1, cols, d1, d2, board, res) // 解除标记 cols[c], d1[id1], d2[id2] = false, false, false &#125; &#125;&#125; 解题思路","tags":[{"name":"算法","slug":"算法","permalink":"http://lcf12307.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"剪枝","slug":"剪枝","permalink":"http://lcf12307.github.io/tags/%E5%89%AA%E6%9E%9D/"}]},{"title":"刷题心得/树/二叉树的层次遍历","date":"2020-02-09T16:00:00.000Z","path":"2020/02/10/刷题心得/树/二叉树的层次遍历/","text":"题目给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。 例如: 123456789101112131415给定二叉树: [3,9,20,null,null,15,7], 3 &#x2F; \\ 9 20 &#x2F; \\ 15 7返回其层次遍历结果：[ [3], [9,20], [15,7]] 代码12345678910111213141516171819202122232425/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func levelOrder(root *TreeNode) [][]int &#123; res := [][]int&#123;&#125; return dfs(root, 0, res)&#125;func dfs(root *TreeNode, level int, res [][]int) [][]int &#123; if root == nil &#123; return res &#125; if level &gt;= len(res) &#123; res = append(res, []int&#123;&#125;) &#125; res[level] = append(res[level], root.Val) res = dfs(root.Left, level+1, res) res = dfs(root.Right, level+1, res) return res&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://lcf12307.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"树","slug":"树","permalink":"http://lcf12307.github.io/tags/%E6%A0%91/"}]},{"title":"刷题心得/树/二叉树的最大深度","date":"2020-02-09T16:00:00.000Z","path":"2020/02/10/刷题心得/树/二叉树的最大深度/","text":"题目给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例： 123456789给定二叉树 [3,9,20,null,null,15,7]， 3 &#x2F; \\ 9 20 &#x2F; \\ 15 7返回它的最大深度 3 。 代码1234567891011121314func maxDepth(root *TreeNode) int &#123; if root == nil &#123; return 0 &#125; return 1 + max(maxDepth(root.Left), maxDepth(root.Right))&#125;func max(a, b int) int &#123; if a &gt; b &#123; return a &#125; return b&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://lcf12307.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"树","slug":"树","permalink":"http://lcf12307.github.io/tags/%E6%A0%91/"}]},{"title":"【贪心算法】买卖股票的最佳时期2","date":"2020-02-09T16:00:00.000Z","path":"2020/02/10/刷题心得/贪心算法/买卖股票的最佳时机/","text":"题目给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 1234输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 3 天（股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。 随后，在第 4 天（股票价格 &#x3D; 3）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出, 这笔交易所能获得利润 &#x3D; 6-3 &#x3D; 3 。 示例 2: 12345输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3: 123输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 解题代码123456789101112func maxProfit(prices []int) int &#123; profit := 0 for i, p := range prices &#123; if i + 1 &gt;= len(prices) &#123; break &#125; if p &lt; prices[i+1] &#123; profit += prices[i+1] - p &#125; &#125; return profit&#125; 解题思路暴力破解直接循环嵌套 maphash存储每个有多少个元素 排序拍完序之后遍历个数 分治分成一半 如果左边的众数等于右边众数的话，则返回该数 否则则判断两个众数哪个更多","tags":[{"name":"算法","slug":"算法","permalink":"http://lcf12307.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"贪心","slug":"贪心","permalink":"http://lcf12307.github.io/tags/%E8%B4%AA%E5%BF%83/"}]},{"title":"【递归分治】括号生成","date":"2020-02-09T16:00:00.000Z","path":"2020/02/10/刷题心得/递归分治/括号生成/","text":"题目给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。 例如，给出 n = 3，生成结果为： 1234567[ &quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot;] 代码1234567891011121314151617181920func generateParenthesis(n int) []string &#123; res := make([]string, 0, n*n) bytes := make([]byte, 2*n) dfs(n, n, 0, bytes, &amp;res) return res&#125;func dfs(left, right, idx int, bytes []byte, res *[]string) &#123; if left == 0 &amp;&amp; right == 0 &#123; *res = append(*res, string(bytes)) return &#125; if left &gt; 0 &#123; bytes[idx] = '(' dfs(left - 1, right, idx + 1, bytes, res) &#125; if right &gt;0 &amp;&amp; right &lt; left &#123; bytes[idx] = ')' dfs(left, right-1, idx+1, bytes, res) &#125;&#125; 1234567891011121314151617181920212223242526272829func generateParenthesis(n int) []string &#123; res := make([]string, 0, n*n) bytes := make([]byte, n*2) dfs(n, n, 0, bytes, &amp;res) return res&#125;func dfs(left, right, idx int, bytes []byte, res *[]string) &#123; // 所有符号都添加完毕 if left == 0 &amp;&amp; right == 0 &#123; *res = append(*res, string(bytes)) return &#125; // \"(\" 不用担心匹配问题， // 只要 left &gt; 0 就可以直接添加 if left &gt; 0 &#123; bytes[idx] = '(' dfs(left-1, right, idx+1, bytes, res) &#125; // 想要添加 \")\" 时 // 需要 left &lt; right， // 即在 bytes[:idx] 至少有一个 \"(\" 可以与 这个 \")\" 匹配 if right &gt; 0 &amp;&amp; left &lt; right &#123; bytes[idx] = ')' dfs(left, right-1, idx+1, bytes, res) &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://lcf12307.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"递归","slug":"递归","permalink":"http://lcf12307.github.io/tags/%E9%80%92%E5%BD%92/"}]},{"title":"刷题心得/递归分治/求众数","date":"2020-02-08T16:00:00.000Z","path":"2020/02/09/刷题心得/递归分治/求众数/","text":"题目给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在多数元素。 示例 1: 12输入: [3,2,3]输出: 3 示例 2: 12输入: [2,2,1,1,1,2,2]输出: 2 解题代码123456789101112131415func majorityElement(nums []int) int &#123; x, t := nums[0], 1 for i := 1; i &lt; len(nums); i++ &#123; switch &#123; case x == nums[i]: t ++ case t &gt; 0: t -- default: x = nums[i] t = 1 &#125; &#125; return x&#125; 解题思路暴力破解直接循环嵌套 maphash存储每个有多少个元素 排序拍完序之后遍历个数 分治分成一半 如果左边的众数等于右边众数的话，则返回该数 否则则判断两个众数哪个更多","tags":[{"name":"算法","slug":"算法","permalink":"http://lcf12307.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"分治","slug":"分治","permalink":"http://lcf12307.github.io/tags/%E5%88%86%E6%B2%BB/"}]},{"title":"【递归和分治】x的n次方","date":"2020-02-08T16:00:00.000Z","path":"2020/02/09/刷题心得/递归分治/求指数/","text":"题目 实现 pow(x, n) ，即计算 x 的 n 次幂函数。 示例 1: 12输入: 2.00000, 10输出: 1024.00000 示例 2: 12输入: 2.10000, 3输出: 9.26100 示例 3: 123输入: 2.00000, -2输出: 0.25000解释: 2-2 &#x3D; 1&#x2F;22 &#x3D; 1&#x2F;4 &#x3D; 0.25 说明: -100.0 &lt; x &lt; 100.0n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。 解题代码12345678910111213141516171819func myPow(x float64, n int) float64 &#123; if n &lt; 0 &#123; return 1.0/pow(x, -n) &#125; return pow(x, n)&#125;func pow(x float64, n int) float64 &#123; if x == 0 &#123; return 0 &#125; if n == 0 &#123; return 1 &#125; res := pow(x, n&gt;&gt;1) if n &amp; 1 == 0 &#123; return res * res &#125; return res * res * x&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://lcf12307.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"分治","slug":"分治","permalink":"http://lcf12307.github.io/tags/%E5%88%86%E6%B2%BB/"}]},{"title":"刷题心得/树/二叉搜索树的最近公共祖先","date":"2020-02-07T16:00:00.000Z","path":"2020/02/08/刷题心得/树/二叉搜索树的最近公共祖先/","text":"题目给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5] 示例 1:123输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 8输出: 6 解释: 节点 2 和节点 8 的最近公共祖先是 6。 示例 2:123输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 4输出: 2解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。 解题代码12345678910111213func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode &#123; return helper(root, p.Val, q.Val)&#125;func helper(root *TreeNode, p, q int) *TreeNode &#123; r := root.Val if p &lt; r &amp;&amp; q &lt; r &#123; return helper(root.Left, p, q) &#125; else if p &gt; r &amp;&amp; q &gt; r &#123; return helper(root.Right, p, q) &#125; return root&#125; 思路 对树进行中序排列 如果最后数组是升序的，即二叉搜索树 递归的判断树的子节点是不是满足大小范围条件","tags":[{"name":"算法","slug":"算法","permalink":"http://lcf12307.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"树","slug":"树","permalink":"http://lcf12307.github.io/tags/%E6%A0%91/"}]},{"title":"刷题心得/树/二叉树的最近公共祖先","date":"2020-02-07T16:00:00.000Z","path":"2020/02/08/刷题心得/树/二叉树的最近公共祖先/","text":"题目给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4] 示例 1: 123输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1输出: 3解释: 节点 5 和节点 1 的最近公共祖先是节点 3。 示例 2: 123输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4输出: 5解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。 解题代码12345678910111213141516func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode &#123; if root == nil || root.Val == p || root.Val == q &#123; return root &#125; l := lowestCommonAncestor(root.Left, p, q) r := lowestCommonAncestor(root.Right, p, q) if l != nil &amp;&amp; r != nil &#123; return root &#125; if l == nil &#123; return r &#125; return l&#125; 思路 对树进行中序排列 如果最后数组是升序的，即二叉搜索树 递归的判断树的子节点是不是满足大小范围条件","tags":[{"name":"算法","slug":"算法","permalink":"http://lcf12307.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"树","slug":"树","permalink":"http://lcf12307.github.io/tags/%E6%A0%91/"}]},{"title":"刷题心得/树/验证二叉搜索树","date":"2020-02-07T16:00:00.000Z","path":"2020/02/08/刷题心得/树/验证二叉搜索树/","text":"题目给定一个二叉树，判断其是否是一个有效的二叉搜索树。 假设一个二叉搜索树具有如下特征： 节点的左子树只包含小于当前节点的数。节点的右子树只包含大于当前节点的数。所有左子树和右子树自身必须也是二叉搜索树。 示例 1:输入: 1234 2 &#x2F; \\ 1 3输出: true 示例 2:123456789输入: 5 &#x2F; \\ 1 4 &#x2F; \\ 3 6输出: false解释: 输入为: [5,1,4,null,null,3,6]。 根节点的值为 5 ，但是其右子节点值为 4 。 解题代码123456789101112func isValidBST(root *TreeNode) bool &#123; MIN, MAX := -1&lt;&lt;63, 1&lt;&lt;63-1 return recur(root, MIN, MAX)&#125;func recur(root *TreeNode, min,max int) bool &#123; if root == nil &#123; return false &#125; return root.Val &gt; min &amp;&amp; root.Val &lt; max &amp;&amp; recur(root.left, min, root.Val) &amp;&amp; recur(root.right, root.Val, max)&#125; 思路 对树进行中序排列 如果最后数组是升序的，即二叉搜索树 递归的判断树的子节点是不是满足大小范围条件","tags":[{"name":"算法","slug":"算法","permalink":"http://lcf12307.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"树","slug":"树","permalink":"http://lcf12307.github.io/tags/%E6%A0%91/"}]},{"title":"刷题心得/哈希表/异位词","date":"2020-02-06T16:00:00.000Z","path":"2020/02/07/刷题心得/哈希表/异位词/","text":"题目给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。 示例 1: 12输入: s &#x3D; &quot;anagram&quot;, t &#x3D; &quot;nagaram&quot;输出: true 示例 2: 12输入: s &#x3D; &quot;rat&quot;, t &#x3D; &quot;car&quot;输出: false 说明:你可以假设字符串只包含小写字母。 代码12345678910111213func isAnagram(s string, t string) bool &#123; if len(s) != len(t) &#123; return false &#125; sr := []rune&#123;s&#125; tr := []rune&#123;t&#125; rec := make(map[rune]int, len(s)) for i:=0; i&lt;len(s); i++ &#123; rec[sr[i]] ++ rec[tr[i]] -- &#125; for &#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://lcf12307.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"哈希表","slug":"哈希表","permalink":"http://lcf12307.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"}]},{"title":"【字符串】最长无重复子串","date":"2020-02-04T16:00:00.000Z","path":"2020/02/05/刷题心得/字符串/最长无重复子串/","text":"题目给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 输入: “abcabcbb”输出: 3解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。示例 2: 输入: “bbbbb”输出: 1解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。示例 3: 输入: “pwwkew”输出: 3 解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。 代码12345678910111213141516171819202122func lengthOfLongestSubstring(s string) int &#123; // 设置一个ascii 数组 locations := [256]int&#123;&#125; // 设定初始值 -1 for i:=0; i&lt; len(locations); i ++ &#123; locations[i] = -1 &#125; // 起始位置和最大值 start, max := 0,0 for i:=0; i&lt;len(s); i++ &#123; // 如果上次重复的位置比当前的start要大， 重设起始位置 if locations[s[i]] &gt;= start &#123; start = locations[s[i]] + 1 // 如果没有重复值， 更新最大值 &#125; else if i + 1 - start &gt; max &#123; max = i + 1 - start &#125; // 记录该字符上次出现的位置 locations[s[i]] = i &#125; return max &#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://lcf12307.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"字符串","slug":"字符串","permalink":"http://lcf12307.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"【栈和队列】合法括号","date":"2020-02-04T16:00:00.000Z","path":"2020/02/05/刷题心得/栈和队列/合法括号/","text":"题目给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。注意空字符串可被认为是有效字符串。 1234567891011121314151617181920示例 1:输入: &quot;()&quot;输出: true示例 2:输入: &quot;()[]&#123;&#125;&quot;输出: true示例 3:输入: &quot;(]&quot;输出: false示例 4:输入: &quot;([)]&quot;输出: false示例 5:输入: &quot;&#123;[]&#125;&quot;输出: true 代码12345678910111213141516171819202122232425func isValid(s string) bool &#123; size := len(s) stack := make([]byte, size) top := 0 for i := 0; i &lt; size; i++ &#123; c := s[i] switch c &#123; case ')', ']', '&#125;': if top &gt; 0 &amp;&amp; stack[top - 1] == c &#123; top -- &#125; else &#123; return false &#125; case '(': stack[top] = c + 1 // ( + 1 =) top ++ case '[', '&#123;': stack[top] = c + 2 // [ + 2 =] top ++ default: return false &#125; &#125; return top == 0&#125; 解题思路检测到左括号，就将对应的括号压入 检测到右括号，就将对应的括号去掉，如果没有，则返回false","tags":[{"name":"算法","slug":"算法","permalink":"http://lcf12307.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"栈","slug":"栈","permalink":"http://lcf12307.github.io/tags/%E6%A0%88/"}]},{"title":"刷题心得/栈和队列/滑动窗口最大值","date":"2020-02-04T16:00:00.000Z","path":"2020/02/05/刷题心得/栈和队列/滑动窗口最大值/","text":"题目给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。 返回滑动窗口中的最大值。 示例: 1234567891011121314输入: nums &#x3D; [1,3,-1,-3,5,3,6,7], 和 k &#x3D; 3输出: [3,3,5,5,6,7] 解释: 滑动窗口的位置 最大值--------------- -----[1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 提示： 你可以假设 k 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。 进阶： 你能在线性时间复杂度内解决此题吗？ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445// 参看 https://leetcode.com/problems/sliding-window-maximum/discuss/65881/O(n)-solution-in-Java-with-two-simple-pass-in-the-arrayfunc maxSlidingWindow(nums []int, k int) []int &#123; size := len(nums) if k &lt;= 1 &#123; return nums &#125; g := k - 1 // 比参考文章的分组少一个，可以减少 max 函数的调用，理论上可以加速。 left := make([]int, size) for i := 0; i &lt; size; i++ &#123; if i%g == 0 &#123; left[i] = nums[i] &#125; else &#123; left[i] = max(nums[i], left[i-1]) &#125; &#125; right := make([]int, size) // size-1 很可能不是那组的最后一个，需要单独列出 right[size-1] = nums[size-1] for j := size - 2; j &gt;= 0; j-- &#123; if (j+1)%g == 0 &#123; right[j] = nums[j] &#125; else &#123; right[j] = max(nums[j], right[j+1]) &#125; &#125; res := make([]int, size-k+1) for i := 0; i &lt;= size-k; i++ &#123; // right[i] 中保存了 nums[i:g*(i/g+1)] 中的最大值 // left[i+k-1] 中保存了 nums[g*(i/g+1):i+k] 中的最大值 res[i] = max(right[i], left[i+k-1]) &#125; return res&#125;func max(a, b int) int &#123; if a &gt; b &#123; return a &#125; return b&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://lcf12307.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"栈","slug":"栈","permalink":"http://lcf12307.github.io/tags/%E6%A0%88/"}]},{"title":"【栈和队列】用栈实现队列","date":"2020-02-04T16:00:00.000Z","path":"2020/02/05/刷题心得/栈和队列/用栈实现队列/","text":"题目使用栈实现队列的下列操作： push(x) – 将一个元素放入队列的尾部。pop() – 从队列首部移除元素。peek() – 返回队列首部的元素。empty() – 返回队列是否为空。示例: 1234567MyQueue queue &#x3D; new MyQueue();queue.push(1);queue.push(2); queue.peek(); &#x2F;&#x2F; 返回 1queue.pop(); &#x2F;&#x2F; 返回 1queue.empty(); &#x2F;&#x2F; 返回 false 说明: 你只能使用标准的栈操作 – 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667type MyQueue struct &#123; arr []int&#125;/** Initialize your data structure here. */func Constructor() MyQueue &#123; return MyQueue&#123;&#125;&#125;/** Push element x to the back of queue. */func (this *MyQueue) Push(x int) &#123; if this.arr == nil &#123; this.arr = make([]int, 0) &#125; this.arr = append(this.arr, x)&#125;/** Removes the element from in front of queue and returns that element. */func (this *MyQueue) Pop() int &#123; if this.arr == nil &#123; this.arr = make([]int, 0) return 0 &#125; if len(this.arr) &lt;= 0 &#123; return 0 &#125; a := this.arr[0] this.arr = this.arr[1:] return a&#125;/** Get the front element. */func (this *MyQueue) Peek() int &#123; if this.arr == nil &#123; this.arr = make([]int, 0) return 0 &#125; if len(this.arr) &lt;= 0 &#123; return 0 &#125; return this.arr[0]&#125;/** Returns whether the queue is empty. */func (this *MyQueue) Empty() bool &#123; if this.arr == nil || len(this.arr) &lt;= 0 &#123; return true &#125; return false&#125;/** * Your MyQueue object will be instantiated and called as such: * obj := Constructor(); * obj.Push(x); * param_2 := obj.Pop(); * param_3 := obj.Peek(); * param_4 := obj.Empty(); */","tags":[{"name":"算法","slug":"算法","permalink":"http://lcf12307.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"栈","slug":"栈","permalink":"http://lcf12307.github.io/tags/%E6%A0%88/"}]},{"title":"刷题心得/栈和队列/第k大元素","date":"2020-02-04T16:00:00.000Z","path":"2020/02/05/刷题心得/栈和队列/第k大元素/","text":"题目设计一个找到数据流中第K大元素的类（class）。注意是排序后的第K大元素，不是第K个不同的元素。 你的 KthLargest 类需要一个同时接收整数 k 和整数数组nums 的构造器，它包含数据流中的初始元素。每次调用 KthLargest.add，返回当前数据流中第K大的元素。 示例: 12345678int k = 3;int[] arr = [4,5,8,2];KthLargest kthLargest = new KthLargest(3, arr);kthLargest.add(3); // returns 4kthLargest.add(5); // returns 5kthLargest.add(10); // returns 5kthLargest.add(9); // returns 8kthLargest.add(4); // returns 8 说明:你可以假设 nums 的长度≥ k-1 且k ≥ 1。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package problem0703import ( \"container/heap\")// KthLargest object will be instantiated and called as such:// obj := Constructor(k, nums);// param_1 := obj.Add(val);type KthLargest struct &#123; k int heap intHeap&#125;// Constructor 创建 KthLargestfunc Constructor(k int, nums []int) KthLargest &#123; h := intHeap(nums) heap.Init(&amp;h) for len(h) &gt; k &#123; heap.Pop(&amp;h) &#125; return KthLargest&#123; k: k, heap: h, &#125;&#125;// Add 负责添加元素func (kl *KthLargest) Add(val int) int &#123; heap.Push(&amp;kl.heap, val) if len(kl.heap) &gt; kl.k &#123; heap.Pop(&amp;kl.heap) &#125; return kl.heap[0]&#125;type intHeap []intfunc (h intHeap) Len() int &#123; return len(h)&#125;func (h intHeap) Less(i, j int) bool &#123; return h[i] &lt; h[j]&#125;func (h intHeap) Swap(i, j int) &#123; h[i], h[j] = h[j], h[i]&#125;func (h *intHeap) Push(x interface&#123;&#125;) &#123; // Push 使用 *h，是因为 // Push 增加了 h 的长度 *h = append(*h, x.(int))&#125;func (h *intHeap) Pop() interface&#123;&#125; &#123; // Pop 使用 *h ，是因为 // Pop 减短了 h 的长度 res := (*h)[len(*h)-1] *h = (*h)[:len(*h)-1] return res&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://lcf12307.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"队列","slug":"队列","permalink":"http://lcf12307.github.io/tags/%E9%98%9F%E5%88%97/"}]},{"title":"【链表和数组】K个一组反转链表","date":"2020-02-03T16:00:00.000Z","path":"2020/02/04/刷题心得/链表和数组/K个一组反转链表/","text":"题目给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。 k 是一个正整数，它的值小于或等于链表的长度。 如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。 示例 : 给定这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5 当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5 当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5 说明 : 你的算法只能使用常数的额外空间。你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 https://leetcode-cn.com/problems/reverse-nodes-in-k-group/ 代码12345678910/** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */func reverseKGroup(head *ListNode, k int) *ListNode &#123; &#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://lcf12307.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"链表","slug":"链表","permalink":"http://lcf12307.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"【链表和数组】两两交换链表中的节点","date":"2020-02-03T16:00:00.000Z","path":"2020/02/04/刷题心得/链表和数组/两两交换链表中的节点/","text":"两两交换链表中的节点给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 示例: 1给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3. \\24. 两两交换链表中的节点 - 力扣（LeetCode） 代码123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */func swapPairs(head *ListNode) *ListNode &#123; if head == nil || head.Next == nil &#123; return head &#125; newHead := head.Next head.Next = swapPairs(newHead.Next) newHead.Next = head return newHead&#125;func swapPairs(head *ListNode) *ListNode &#123; if head == nil || head.Next == nil &#123; return head &#125; var prev,prev.Next *ListNode for head != nil &amp;&amp; head.Next != nil &#123; prev.Next := head.Next head.Next = prev.Next prev.Next.Next = head &#125; if head != nil &#123; prev.Next = head &#125;&#125; 思路本题采用递归的解法 首先对特殊情况进行处理 其次交换当前两个节点的位置，并对之后的节点进行处理 返回结果","tags":[{"name":"算法","slug":"算法","permalink":"http://lcf12307.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"链表","slug":"链表","permalink":"http://lcf12307.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"【链表和数组】反转链表","date":"2020-02-03T16:00:00.000Z","path":"2020/02/04/刷题心得/链表和数组/反转链表/","text":"反转一个单链表。示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL进阶:你可以迭代或递归地反转链表。你能否用两种方法解决这道题？ \\206. 反转链表 - 力扣（LeetCode） 解题思路新建一个空节点 作为反转后的串的顶部节点 遍历每个节点 并执行以下操作 临时变量存储next的值 head的next指向prev prev 指向当前的head head指向下一个节点 代码1234567891011121314151617/** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */func reverseList(head *ListNode) *ListNode &#123; var prev *ListNode for head != nil &#123; temp := head.Next head.Next = prev prev = head head = temp &#125; return prev&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://lcf12307.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"链表","slug":"链表","permalink":"http://lcf12307.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"【链表和数组】环形链表","date":"2020-02-03T16:00:00.000Z","path":"2020/02/04/刷题心得/链表和数组/环形链表/","text":"题目给定一个链表，判断链表中是否有环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 示例 1：输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。 示例 2：输入：head = [1,2], pos = 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。 示例 3：输入：head = [1], pos = -1输出：false解释：链表中没有环。 进阶： 你能用 O(1)（即，常量）内存解决此问题吗？ \\141. 环形链表 - 力扣（LeetCode） 代码1234567891011121314151617/** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */func hasCycle(head *ListNode) bool &#123; if head == nil &#123; return false &#125; slow, fast := head, head.Next for fast != nil &amp;&amp; fast.Next != nil &amp;&amp; slow != fast &#123; slow, fast = slow.Next, fast.Next.Next &#125; return slow == fast&#125; 解题思路如果快慢指针能相遇，则存在环","tags":[{"name":"算法","slug":"算法","permalink":"http://lcf12307.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"链表","slug":"链表","permalink":"http://lcf12307.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"【链表和数组】环形链表2","date":"2020-02-03T16:00:00.000Z","path":"2020/02/04/刷题心得/链表和数组/环形链表2/","text":"题目给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 说明：不允许修改给定的链表。 示例 1： 输入：head = [3,2,0,-4], pos = 1输出：tail connects to node index 1解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 输入：head = [1,2], pos = 0输出：tail connects to node index 0解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 输入：head = [1], pos = -1输出：no cycle解释：链表中没有环。 进阶：你是否可以不用额外空间解决此题？ 代码1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */func detectCycle(head *ListNode) *ListNode &#123; if head == nil || head.Next == nil &#123; return nil &#125; slow, fast := head.Next, head.Next.Next for fast != nil &amp;&amp; fast.Next != nil &amp;&amp; slow != fast &#123; slow, fast = slow.Next, fast.Next.Next &#125; if slow != fast &#123; return nil &#125; for slow != head &#123; slow, head = slow.Next, head.Next &#125; return slow&#125; 解题思路如果快慢指针能相遇，则存在环","tags":[{"name":"算法","slug":"算法","permalink":"http://lcf12307.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"链表","slug":"链表","permalink":"http://lcf12307.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"【面试复盘】头条面试","date":"2020-02-03T16:00:00.000Z","path":"2020/02/04/面试/复盘/2.13头条面试/","text":"一面基础知识redis的雪崩、击穿、穿透zookeepergolang里的线程安全map1sync.map redis cluster算法题手动实现parseInt12345func parseInt(s string) (i int, err error) &#123; // 去掉空格 // 判断为空 // 判断第一个字符是否是正负号 // 增加时判 二面业务算法题最长无重复子串1234567891011121314151617func lengthOfLongestSubstring(s string) &#123; location := [256]int&#123;&#125; for i:=range location &#123; location[i] = -1 &#125; left, maxLen := 0, 0 for i := 0; i&lt; len(s); i++ &#123; if location[i] &gt;= left &#123; left = location[s[i]] + 1 &#125; else if i + 1 - left &gt; maxLen &#123; maxLen = i + 1 - left &#125; location[s[i]] = i &#125;&#125;","tags":[{"name":"复盘","slug":"复盘","permalink":"http://lcf12307.github.io/tags/%E5%A4%8D%E7%9B%98/"}]},{"title":"【常见问题】hexo","date":"2020-01-21T06:51:25.000Z","path":"2020/01/21/常见问题/hexo常见问题/","text":"由于刚刚开始使用hexo，对很多操作都不是很理解，因此，进行了一些调研，调研结果如下，包括摘要，标签等等方式 如何设置文章摘要?在 Markdown 中加 `` 文章如何添加多个标签有两种多标签格式 1tags: [a, b, c] 或 1234tags: - a - b - c 修改 brand 图片（菜单上方背景图）替换 themes\\indigo\\source\\img\\brand.jpg，保持原文件名不变。 如何在文章中使用图标先到 fontawesome 找到你需要的图标名，比如：book，按以下格式使用： 1&lt;i class&#x3D;&quot;icon icon-book&quot;&gt;&lt;&#x2F;i&gt; 图标样式前缀均为 icon，此外还有 5 个图标大小调节类和 1 个间距类。 1234567891011121314&lt;!-- 1.3倍大小 --&gt;&lt;i class&#x3D;&quot;icon icon-book icon-lg&quot;&gt;&lt;&#x2F;i&gt;&lt;!-- 2倍大小 --&gt;&lt;i class&#x3D;&quot;icon icon-book icon-2x&quot;&gt;&lt;&#x2F;i&gt;&lt;!-- 3倍大小 --&gt;&lt;i class&#x3D;&quot;icon icon-book icon-3x&quot;&gt;&lt;&#x2F;i&gt;&lt;!-- 4倍大小 --&gt;&lt;i class&#x3D;&quot;icon icon-book icon-4x&quot;&gt;&lt;&#x2F;i&gt;&lt;!-- 5倍大小 --&gt;&lt;i class&#x3D;&quot;icon icon-book icon-5x&quot;&gt;&lt;&#x2F;i&gt;&lt;!-- 5px右边距 --&gt;&lt;i class&#x3D;&quot;icon icon-book icon-pr&quot;&gt;&lt;&#x2F;i&gt;&lt;!-- 5px左边距 --&gt;&lt;i class&#x3D;&quot;icon icon-book icon-pl&quot;&gt;&lt;&#x2F;i&gt; 个别图标无法显示如果你的浏览器安装了 ADBlock，它会屏蔽 SNS 相关的内容，比如：Github。 解决办法：可配置 ADBlock 不在你的站点运行。 生成站点后没有样式安装less 更改样式后网站没有生效确认非缓存问题后，执行 hexo clean 再进行生成上传。 更改站点配色编辑 themes\\indigo\\source\\css\\_partial\\variable.less，更改对应的颜色变量。 配色参考：Material Design Color Palette Generator 注意：使用自定义配色时需把主题配置中的 cdn 关闭，cdn: false。 添加404页面在 hexo/source 目录内新建 404.html。 设置元数据信息，如果不想套用主题布局可设置 layout 为 false。 123layout: false title: &quot;My Blog Name | 404&quot;--- 在博客中使用 Emoji参考 Can i use emoji in mypage? 自行修改样式线上不生效因为主题默认引用 cdn 样式，只有主题更新时，cdn 中的样式才会变化。 如果想使用自己修改的样式，需要把修改配置中的 cdn: false。这样就不在引用 cdn 资源，使用本地资源了。","tags":[{"name":"hexo","slug":"hexo","permalink":"http://lcf12307.github.io/tags/hexo/"}]},{"title":"【常见问题】nginx搭建的服务器 报No input file specified错","date":"2020-01-21T06:51:25.000Z","path":"2020/01/21/常见问题/No input file specified/","text":"nginx搭建的服务器 报No input file specified错 我把php-fpm重启下就能访问了 然后没过多久又抱No input file specified错 php-fpm在重启下又可以正常访问了 您的服务器不支持 PATH_INFO; 在php.ini文件里面修改： 1、增加一行（这个最重要） ​ fastcgi.impersonate = 1 2、修改两项（解开注释就可以了） ​ cgi.fix_pathinfo=1​ cgi.force_redirect = 0","tags":[{"name":"php","slug":"php","permalink":"http://lcf12307.github.io/tags/php/"},{"name":"服务器","slug":"服务器","permalink":"http://lcf12307.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]},{"title":"【吊打面试官】HTTP，TCP， socket，RPC 与gRPC都是啥？","date":"2020-01-20T16:00:00.000Z","path":"2020/01/21/面试/要点整理/HTTP，TCP， socket，RPC 与gRPC都是啥？/","text":"大家在面试题里看到过那么多次tcp，http， rpc等等，但是一直没有放到一起对比，今天我们一起对比看下，这几个有什么不同 TCP/HTTP与socket首先回顾下计算机网络的五(七)层协议：物理层、数据链路层、网络层、传输层、(会话层、表示层)和应用层。那么从协议上来讲： TCP是传输层协议，主要解决数据如何在网络中传输 HTTP 是应用层协议，主要解决如何包装数据（文本信息），是建立在tcp协议之上的应用。TCP协议是以二进制数据流的形式解决传输层的事儿，但对上层的应用开发极不友好，所以面向应用层的开发又产生了HTTP协议。 而socket 是针对TCP或UDP的具体接口实现，提供了在传输层进行网络编程的方法。 以上内容我们应该都听说的比较多了，下面主要来谈一谈RPC。 什么是RPC？ RPC(Remote Procedure Call)是远程过程调用，比如说现在有两台服务器A, B，一个在A服务器上的应用想要调用B服务器上的应用提供的某个，由于不在两个方法不在一个内存空间，不能直接调用，需要通过网络表达调用的语义和传达调用的数据。常存在于分布式系统中。 为何有http协议之后，还要RPC调用？ RPC跟HTTP不是对立面，RPC中可以使用HTTP作为通讯协议。RPC是一种设计、实现框架，通讯协议只是其中一部分。 RPC的本质是提供了一种轻量无感知的跨进程通信的方式，在分布式机器上调用其他方法与本地调用无异（远程调用的过程是透明的，你并不知道这个调用的方法是部署在哪里，通过PRC能够解耦服务）。RPC是根据语言的API来定义的，而不是基于网络的应用来定义的，调用更方便，协议私密更安全、内容更小效率更高。 http接口是在接口不多、系统与系统交互较少的情况下，解决信息孤岛初期常使用的一种通信手段；优点就是简单、直接、开发方便。利用现成的http协议 进行传输。但是如果是一个大型的网站，内部子系统较多、接口非常多的情况下，RPC框架的好处就显示出来了，首先（基于TCP协议的情况下）就是长链接，不必每次通信都要像http 一样去3次握手什么的，减少了网络开销；其次就是RPC框架一般都有注册中心，有丰富的监控管理；发布、下线接口、动态扩展等，对调用方来说是无感知、统 一化的操作。第三个来说就是安全性。最后就是最近流行的服务化架构、服务化治理，RPC框架是一个强力的支撑。 RPC 中要解决的问题： 建立通信：在客户端与服务端建立起数据传输通道，大都是TCP连接（gRPC使用了HTTP2）。 寻址：A服务器上的应用需要告诉RPC框架：B服务器地址、端口，调用函数名称。所以必须实现待调用方法到call ID的映射。 序列化与反序列化：由于网络协议都是二进制的，所以调用方法的参数在进行传递时首先要序列化成二进制，B服务器收到请求后要再对参数进行反序列化。恢复为内存中的表达方式，找到对应的方法进行本地调用，得到返回值。返回值从B到A的传输仍要经过序列化与反序列化的过程。 常见名词小结 名词 特点 RPC 远程过程调用（分布式、微服务间的方法调用） HTTP 无状态，每次请求都要发送一个request，服务器响应之后就断掉（http header中的keep-alive指的是tcp） TCP 面向连接，三次握手保证通信可靠 UDP 非面向连接，不可靠，速度快（可以手动对数据收发进行验证，IM系统多采用，QQ） socket TCP协议的接口实现，面向传输层进行网络编程 单独来谈一谈gRPCgRPC是谷歌开源的一个 RPC 框架，面向移动和 HTTP/2 设计。 内容交换格式采用ProtoBuf(Google Protocol Buffers)，开源已久，提供了一种灵活、高效、自动序列化结构数据的机制，作用与XML，Json类似，但使用二进制，（反）序列化速度快，压缩效率高。 传输协议 采用http2，性能比http1.1好了很多 和很多RPC系统一样，服务端负责实现定义好的接口并处理客户端的请求，客户端根据接口描述直接调用需要的服务。客户端和服务端可以分别使用gPRC支持的不同语言实现。 ProtoBuf 具有强大的IDL（interface description language，接口描述语言）和相关工具集（主要是protoc）。用户写好.proto描述文件后，protoc可以将其编译成众多语言的接口代码。 补充：HTTP/2介绍新特性： 新的二进制格式 HTTP1.X都是基于文本解析，而因为文本表现形式的多样性，基于文本协议的格式解析天然存在健壮性问题。而采用二进制格式后实现方便且健壮。 多路复用 多个request共享一个连接。 header压缩 在HTTP1.x中header信息很多，且每次都会重复发送，造成很大浪费。HTTP2.0使用encoder减少了传输的header大小，且通信双方都缓存一份包含了header信息的表，此后的请求可以只发送差异数据，避免信息的重复传输，进一步减少需要传输的内容大小。 服务端推送 主要的思想是：当一个客户端请求资源X，而服务器知道它很可能也需要资源Z的情况下，服务器可以在客户端发送请求前，主动将资源Z推送给客户端。这个功能帮助客户端将Z放进缓存以备将来之需。也遵守同源策略，且客户端可以拒绝推送过来的资源。 推荐阅读： 既然有http 请求，为什么还要用rpc调用？ HTTP,HTTP2.0,SPDY,HTTPS你应该知道的一些事 HTTP/2协议–特性扫盲篇 HTTP/2.0相比1.0有哪些重大改进","tags":[{"name":"http","slug":"http","permalink":"http://lcf12307.github.io/tags/http/"},{"name":"rpc","slug":"rpc","permalink":"http://lcf12307.github.io/tags/rpc/"},{"name":"thrift","slug":"thrift","permalink":"http://lcf12307.github.io/tags/thrift/"}]},{"title":"python一行命令创建http服务器","date":"2020-01-20T06:51:25.000Z","path":"2020/01/20/黑科技/python一行创建http服务器/","text":"Python 创建服务器仅需一条命令 对于Python 2，简单搭建Web服务器，只需在需要搭建Web服务器的目录（如C:/ 或 /home/klchang/）下，输入如下命令： 1python -m SimpleHTTPServer 8080 含义为使用 8080端口的创建Web服务器，可以使用浏览器 http://127.0.0.1:8080 或 将 127.0.0.1 替换为本机的外部IP地址，进行访问。 对于Python 3，其创建Web服务器的等价命令，如下： 1python3 -m http.server 8080","tags":[{"name":"python","slug":"python","permalink":"http://lcf12307.github.io/tags/python/"}]},{"title":"搭建一个hexo博客","date":"2020-01-20T06:51:25.000Z","path":"2020/01/20/黑科技/hexo/","text":"一直有一个搭建一个自己的博客的想法，刚好趁着有时间，一边整理，一边更新博客，因此就把博客搭起来了。 采用的是流行的hexo，部署在本地，当然部署也很简单，所以迁移的时候就节省了大量成本，其次就是文档，文档跟我的另外一些文档放在一起。 安装步骤12345678910111213141516171819# 安装node$ brew install node$ node -v$ cd code# 安装 hexo$ sudo npm i hexo-cli -g$ hexo -v# 初始化文件夹$ hexo init blog$ cd blog# 安装相关的文件$ npm install$ npm install hexo-deployer-git --save# 配置github的相关信息$ vim _config.yml# 软链博客文件夹到本地$ ln -sv ~/博客 ~/code/blog/source/_posts# 修改定时脚本$ vim auto.sh 主题安装12345678910# 使用indigo主题，文档如下# https://github.com/yscoder/hexo-theme-indigo/wiki/# 主题默认使用 less 作为 css 预处理工具$ npm install hexo-renderer-less --save# 生成rss$ npm install hexo-generator-feed --save# 生成搜索$ npm install hexo-generator-json-content --save# 生成微信分享二维码$ npm install hexo-helper-qrcode --save hexo常用的命令12345678910111213# 新建帖子$ hexo new \"My New Post\"# 启动本地服务器$ hexo server$ hexo s# 生成文件$ hexo generate$ hexo g# 部署到git上$ hexo deploy $ hexo d# 初始化项目框架$ hexo init &lt;项目名&gt; 新建post的规则1234567title: 搭建一个hexo博客date: 2020-01-20 14:51:25categories: - web前端tags:- node- hero","tags":[{"name":"hexo","slug":"hexo","permalink":"http://lcf12307.github.io/tags/hexo/"},{"name":"node","slug":"node","permalink":"http://lcf12307.github.io/tags/node/"}]},{"title":"【第一课】设计模式","date":"2019-11-13T16:00:00.000Z","path":"2019/11/14/面试/要点整理/设计模式/","text":"本篇文章主要就设计模式的常见问题进行了讨论 六大原则 单一原则 每个类尽量实现独立的功能 里氏替换原则：子类可以扩展父类的功能，但不能改变父类原有的功能 针对继承 依赖倒置原则 避免高层依赖底层 接口隔离原则 接口往小了拆分 迪米特法则 每个单元对其他单元了解要尽可能小 开闭原则 尽量用扩展的方法，不去修改原来逻辑 观察者模式对象间一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。 1. 策略模式( Strategy )定义个策略接口，不同的实现类提供不同的具体策略算法, 同时它们之间可以互相替换. IStrategy 接口定义了策略方法，Strategy1 和 Strategy2 通过实现 IStrategy 提供不同的策略，而 User 组合了 IStrategy ，可以通过给 User 对象设置不同具体实现类来让其获得不同的策略 策略模式.PNG 2. 简单工厂模式( Simple Factory )定义一个用以创建对象的工厂, 根据不同的条件生成不同的对象 注意简单工厂模式与策略模式是不同的，工厂模式是根据给定的条件返回相应的对象，而策略模式是将不同的策略对象传递给使用者以实现不同策略,（好吧，我差点分不清了）详细不同点分析可转这里 简单工厂模式.PNG 3. 工厂模式( Factory )针对每一种产品提供一个工厂类，通过不同的工厂实例来创建不同的产品实例 与简单工厂模式不同点是它要为每一种产品提供一个工厂类，不同工厂类实现同一个工厂接口，返回不同产品，详细分析可转这里 工厂模式.PNG 4. 抽象工厂模式( Abstract Factory )应对产品族概念而生 与工厂模式相比，抽象工厂模式是为了应对产品族 抽象工厂模式.PNG 5. 装饰者模式( Decorator )动态的给一个对象添加一些额外的功能 ComponentImpl 和 Decorator 类都实现了 IComponent 接口，不同的是 ComponentImpl 提供了具体实现，而 Decorator 是先聚合 ComponentImpl 接着在自己的实现方法即 operation() 方法中做些处理（即装饰）后再调用 ComponentImpl 对象的具体实现 装饰者模式.PNG 6. 代理模式( Proxy )封装被代理对象并限制外界对被代理对象的访问 注意区分装饰者模式和代理模式的区别。在代理模式中，ComponentImpl 和 Proxy 类都实现了 IComponent 接口，Proxy 对象中虽然也维护着一个 ComponentImpl 对象，但一般情况下它是代理类自己初始化的，不像装饰者模式是通过 set 进去的，同时在接口方法即 operation() 中代理对象会限制外界对被代理对象的访问，而装饰者模式是装饰者给被装饰者添加额外的行为，详细不同点分析可转这里 代理模式.PNG 7. 模板方法模式( Template )定义一个操作的算法骨架, 并将一些步骤延迟到子类中 AbsTemplate 抽象类中定义了一系列的方法，其中外界唯一能调用的 operation() 方法是 final 的（即不可重写），在该方法中分别调用了 first() 、second() 、third() 方法（即搭好算法框架），子类通过继承抽象类重写不同的方法来添加各自的行为 模板方法模式.PNG 8. 外观模式( Facade )为系统向外界提供一个统一的接口 Fracade 为 ComponentA 、ComponentB 、ComponentC 向外即 ClientA 、ClientB 提供统一的接口 外观模式.PNG 9. 适配器模式( Adapter )将一个类的接口转换成客户希望的另一个接口 比如项目引入第三方类库后应该先封装起来转换成自己需要的接口再使用，防止以后类库出现变更。AdapterA 先将 LibraryClass 封装起来，其对外提供的 operation() 方法中调用 LibraryClass 对象的方法，若以后换类库，只需改 AdapterA 类或者创建新的 Adapter 实现类即可 适配器模式.PNG 10. 桥接模式( Bridge )将抽象部分与实现部分分离，使它们都可以独立的变化 将原本要耦合的上下层抽象出来，上层和下层以组合的方式连接，然后上下层抽象可派生出许多不同方向的子类。AbsShape 封装了 IDrawProgram 接口，这样它的子类想从 DPA 切换到 DPB 或者别的，只需 set 进去就行啦（你看，这 UML 图多像座桥） 桥接模式.PNG 注： 适配器、桥接与外观三模式之间关系 11. 建造者模式( Builder )将一个复杂对象的构建与它的表示分离. 作为 Product 的内部类，Builder 统一了 Product 的整个构建过程，同时在 build 过程中，可以由于 set 值顺序不同等原因产生不同的效果 建造者模式.PNG 12. 观察者模式( Observer )定义了一种一对多的依赖关系,让多个观察者对象同时监听某一主题对象,在它的状态发生变化时,会通知所有的观察者. 先将 Observer 注册到 Observable ，那么当 Observable 状态改变时会通知它持有的所有 Observer ,对了，最好 Observable 中的 mList 的泛型是 WeakReference ,防止内存泄漏 观察者模式.PNG 13. 单例模式( Singleton )保证一个类仅有一个实例,并提供一个访问它的全局控制点. 下图是利用 Java 的语言特性实现的线程安全且能延迟初始化的单例模式，Singleton 中维护着静态私有的 SingleHolder 类， SingleHolder 类中持有个静态常量 sHolder ，Client 若通过 getSingleInstance 方法获取 Singleton 对象则直接返回 SingleHolder 类的 sHolder ，详细分析可转这里 单例模式.PNG 14. 命令模式( Command )将一个请求封装成为一个对象, 使可以用不同的请求对客户进行参数化 Action 封装了具体行为，Command 封装了 Action 并提供空方法 execute() ，它的子类通过重写该方法可在方法里调用 mAction 不同行为达到封装命令的目的，最后 Client 封装了一系列的 Command 对象，并可以通过 notify() 方法一个接着一个调用所持有 Command 对象们的 execute() 方法达到给 Action 传达命令的目的 命令模式.PNG","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://lcf12307.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"【第一课】操作系统","date":"2019-11-12T16:00:00.000Z","path":"2019/11/13/面试/要点整理/操作系统/","text":"本篇文章主要就操作系统的常见面试题进行了讨论 进程同步同步机制需要遵循的原则： 空闲让进：当没有进程处于临界区的时候，应该许可其他进程进入临界区的申请 忙则等待：当前如果有进程处于临界区，如果有其他进程申请进入，则必须等待，保证对临界区的互斥访问 有限等待：对要求访问临界资源的进程，需要在有限时间内进入临界区，防止出现死等 让权等待：当进程无法进入临界区的时候，需要释放处理机，边陷入忙等 死锁是指多个进程在运行过程中，因为争夺资源而造成的一种僵局，如果没有外力推进，处于僵局中的进程就无法继续执行。死锁原因： 竞争资源：请求同一有限资源的进程数多于可用资源数 进程推进顺序非法：进程执行中，请求和释放资源顺序不合理，如资源等待链 死锁产生的必要条件： 互斥条件:进程对所分配的资源进行排他性的使用 请求和保持条件：进程被阻塞的时候并不释放锁申请到的资源 不可剥夺条件：进程对于已经申请到的资源在使用完成之前不可以被剥夺 环路等待条件：发生死锁的时候存在的一个 进程-资源 环形等待链 死锁处理： 预防死锁：破坏产生死锁的4个必要条件中的一个或者多个；实现起来比较简单，但是如果限制过于严格会降低系统资源利用率以及吞吐量 避免死锁：在资源的动态分配中，防止系统进入不安全状态(可能产生死锁的状态)-如银行家算法 检测死锁：允许系统运行过程中产生死锁，在死锁发生之后，采用一定的算法进行检测，并确定与死锁相关的资源和进程，采取相关方法清除检测到的死锁。实现难度大 解除死锁：与死锁检测配合，将系统从死锁中解脱出来（撤销进程或者剥夺资源）。对检测到的和死锁相关的进程以及资源，通过撤销或者挂起的方式，释放一些资源并将其分配给处于阻塞状态的进程，使其转变为就绪态。实现难度大 进程调度算法先来先服务调度算法FCFS：既可以作为作业调度算法也可以作为进程调度算法；按作业或者进程到达的先后顺序依次调度；因此对于长作业比较有利； 短作业优先调度算法SJF：作业调度算法，算法从就绪队列中选择估计时间最短的作业进行处理，直到得出结果或者无法继续执行；缺点：不利于长作业；未考虑作业的重要性；运行时间是预估的，并不靠谱 ； 高相应比算法HRN：响应比=(等待时间+要求服务时间)/要求服务时间； 时间片轮转调度RR：按到达的先后对进程放入队列中，然后给队首进程分配CPU时间片，时间片用完之后计时器发出中断，暂停当前进程并将其放到队列尾部，循环 ; 多级反馈队列调度算法：目前公认较好的调度算法；设置多个就绪队列并为每个队列设置不同的优先级，第一个队列优先级最高，其余依次递减。优先级越高的队列分配的时间片越短，进程到达之后按FCFS放入第一个队列，如果调度执行后没有完成，那么放到第二个队列尾部等待调度，如果第二次调度仍然没有完成，放入第三队列尾部…。只有当前一个队列为空的时候才会去调度下一个队列的进程。 分段分页页是信息的物理单位，是出于系统内存利用率的角度提出的离散分配机制；段是信息的逻辑单位，每个段含有一组意义完整的信息，是出于用户角度提出的内存管理机制 页的大小是固定的，由系统决定；段的大小是不确定的，由用户决定 分页是为了提高内存利用率，而分段是为了满足程序员在编写代码的时候的一些逻辑需求(比如数据共享，数据保护，动态链接等)。 为了减少两次访问内存导致的效率影响，分页管理中引入了快表机制，包含快表机制的内存管理中，当要访问内存数据的时候，首先将页号在快表中查询，如果查找到说明要访问的页表项在快表中，那么直接从快表中读取相应的物理块号；如果没有找到，那么访问内存中的页表，从页表中得到物理地址，同时将页表中的该映射表项添加到快表中(可能存在快表换出算法)。 页面置换算法最佳置换算法：只具有理论意义的算法，用来评价其他页面置换算法。置换策略是将当前页面中在未来最长时间内不会被访问的页置换出去。 先进先出置换算法：简单粗暴的一种置换算法，没有考虑页面访问频率信息。每次淘汰最早调入的页面。 最近最久未使用算法LRU：算法赋予每个页面一个访问字段，用来记录上次页面被访问到现在所经历的时间t，每次置换的时候把t值最大的页面置换出去(实现方面可以采用寄存器或者栈的方式实现)。 时钟算法clock(也被称为是最近未使用算法NRU)：页面设置一个访问位，并将页面链接为一个环形队列，页面被访问的时候访问位设置为1。页面置换的时候，如果当前指针所指页面访问为为0，那么置换，否则将其置为0，循环直到遇到一个访问为位0的页面。 改进型Clock算法：在Clock算法的基础上添加一个修改位，替换时根究访问位和修改位综合判断。优先替换访问位和修改位都是0的页面，其次是访问位为0修改位为1的页面。 最少使用算法LFU：设置寄存器记录页面被访问次数，每次置换的时候置换当前访问次数最少的。","tags":[{"name":"linux","slug":"linux","permalink":"http://lcf12307.github.io/tags/linux/"}]},{"title":"【第一课】系统设计题","date":"2019-11-12T16:00:00.000Z","path":"2019/11/13/面试/要点整理/系统设计题/","text":"设计一个红包雨游戏设计一个唯一id生成器设计一个支付系统设计一个微博系统1234设计一个微博系统，用户之间可以互相关注，如果 A关注了B，B关注了C那么 A间接关注了C且 A与C之间的度为1然后系统有一个功能 输入俩用户 输出他俩之间的 度 设计一个12306抢购系统1234567买票退票同时抢不同区间的票压测验证码","tags":[{"name":"linux","slug":"linux","permalink":"http://lcf12307.github.io/tags/linux/"}]},{"title":"【第一课】linux命令","date":"2019-11-11T16:00:00.000Z","path":"2019/11/12/面试/要点整理/linux/","text":"本篇文章主要就linux命令的常见问题进行了讨论 任务计划格式中，前面5个数字分表表示什么含义？ 答：依次表示：分、时、日、月、周 Linux 查看端口占用情况可以使用 lsof 和 netstat 命令 zcat命令用于不真正解压缩文件，就能显示压缩包中文件的内容的场合。 释放某端口 1netstat -tln &amp;&amp; lsof -i :9001 &amp;&amp; kill -9 9001 &amp;&amp; netstat -tln 删除大于30m的命令 123find ./ -size +50M -exec rm &#123;&#125; \\;&#123;&#125;是一个特殊的字符串，对于每一个匹配的文件，&#123;&#125;会被替换成相应的文件名； 从尾部看日志 1tail -f 链接远程服务器 1ssh crontab 1crontab [-u user] file crontab [-u user] [ -e | -l | -r ] 如果不输file的话， 则接受标准输入 远程拷贝 1scp [参数] [原路径] [目标路径] 万物皆文件 lsof打开的文件可以是： 普通文件 目录 网络文件系统的文件 字符或设备文件 (函数)共享库 管道，命名管道 符号链接 网络文件（例如：NFS file、网络socket，unix域名socket） 还有其它类型的文件，等等 设置命令别名 1alias lsl='ls -lrt' 软链和硬链 12ln cc ccAgain :硬连接；删除一个，将仍能找到；ln -s cc ccTo :符号链接(软链接)；删除源，另一个无法使用；（后面一个ccTo 为新建的文件） 管道 批处理命令连接执行，使用 | 串联: 使用分号 ; 前面成功，则执行后面一条，否则，不执行:&amp;&amp; 前面失败，则后一条执行: || 环境变量 1启动帐号后自动执行的是 文件为 .profile，然后通过这个文件可设置自己的环境变量； 文本处理 find 文件查找 定制搜索 找到后的后续动作 -print的定界符 grep 文本搜索 xargs 命令行参数转换 sort 排序 uniq 消除重复行 用tr进行转换 cut 按列切分文本 paste 按列拼接文本 wc 统计行和字符的工具 sed 文本替换利器 awk 数据流处理工具 磁盘管理 1234567891011查看磁盘空间 df -h查看目录大小 du -sh打包 tar -cvf解包 tar -xvf压缩 gzip解压缩 gunzip bzip 修改权限 123chmodchrow 统计qps","tags":[{"name":"linux","slug":"linux","permalink":"http://lcf12307.github.io/tags/linux/"}]},{"title":"【第一课】数据库","date":"2019-11-08T08:14:00.000Z","path":"2019/11/08/面试/要点整理/数据库/","text":"本篇文章主要就数据库的常见问题进行了讨论 事务的特性1234acid 原子性，一致性 隔离性 持久性事务隔离分为： 读取未提交数据 读取其他事务提交数据可重读 串行化 myisam和innodb的区别12345678910111213141516171819采用MyISAM引擎- R&#x2F;W &gt; 100:1 且update相对较少- 并发不高- 表数据量小- 硬件资源有限- 不支持外键- 不支持事务- 执行selecte较多的时候优先使用- 表锁- 不会死锁采用InnoDB引擎- R&#x2F;W比较小，频繁更新大字段- 表数据量超过1000万，并发高- 安全性和可用性要求高- 支持外键- 执行update inser较多的时候优先使用- delete的时候 innodb会一行一行的删除- 行锁 mysql 性能调优12345678910111213141516171819202122开启查询缓存explain下自己的sql语句并分析只用一行数据的话 limit 1为搜索字段建索引千万不要order by rand()避免selecte *不要设置null尽量少的多表查询拆分大的delete和insert语句， 因为这个操作会锁表，最好不要占用太久选择合适的存储引擎冗余数据使用尽可能小的合适的数据类型读写分离拆分表 垂直拆分和水平拆分在使用InnoDB存储引擎时，如果没有特别的需要，请永远使用一个与业务无关的自增字段作为主键。分析过程：是否有周期性的崩溃-》 增加缓存开启profiling查询慢日志和explain来分析等待时间长-》对服务器调优执行时间长-》对语句调优还不行-&gt; 增加硬件 索引的实现123索引（Index）是帮助MySQL高效获取数据的数据结构mysql的索引是b+树InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的 mysql表示时间数据库中可以用datetime、bigint、timestamp来表示时间 索引可以加快查询速度，那么是不是只要是查询语句需要，就建上索引？123答案是否定的。因为索引虽然加快了查询速度，但索引也是有代价的：索引文件本身要消耗存储空间，同时索引会加重插入、删除和修改记录时的负担，另外，MySQL在运行时也要消耗资源维护索引，因此索引并不是越多越好。一般两种情况下不建议建索引。第一种情况是表记录比较少 另一种不建议建索引的情况是索引的选择性较低。 什么是脏读，不可重复读，幻读](https://juejin.im/entry/5b835dfbf265da43531d0593)123脏读 一个事务中访问到了另外一个事务未提交的数据不可重复读 一个事务读取同一条记录2次，得到的结果不一致幻读 一个事务读取2次，得到的记录条数不一致 乐观锁使用数据版本来实现。 悲观锁12共享锁排它锁 产生死锁的原因123（1） 因为系统资源不足。（2） 进程运行推进的顺序不合适。（3） 资源分配不当等。 产生死锁的四个必要条件1234（1） 互斥条件：一个资源每次只能被一个进程使用。（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。（3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。 死锁1234（1）死锁预防：通过确保死锁的一个必要条件不会满足，保证不会发生死锁（2）死锁检测：允许死锁的发生，但是可以通过系统设置的检测结构及时的检测出死锁的发生，采取一些措施，将死锁清除掉（3）死锁避免：在资源分配过程中，使用某种方法避免系统进入不安全的状态，从而避免发生死锁（4）死锁解除：与死锁检测相配套的一种措施。当检测到系统中已发生死锁，需将进程从死锁状态中解脱出来。 存储过程123### mvcchttp:&#x2F;&#x2F;blog.codinglabs.org&#x2F;articles&#x2F;theory-of-mysql-index.htmlhttps:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;86a1fd2d7406","tags":[{"name":"数据库","slug":"数据库","permalink":"http://lcf12307.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MYSQL","slug":"MYSQL","permalink":"http://lcf12307.github.io/tags/MYSQL/"}]},{"title":"【第一课】网络","date":"2019-11-05T16:00:00.000Z","path":"2019/11/06/面试/要点整理/网络/","text":"本篇文章主要就网络的常见问题进行了讨论 http的特性 123456789无连接无状态。建立在tcp&#x2F;ip协议上 的应用层上。http请求包含三个部分：状态头，请求头，消息主体。http的基本方法包含 get post put delete响应报文包含三个状态：状态行，响应头，响应正文。缺点是明文传输 什么是会话 123456789101112131415客户端打开与服务器的连接发出请求到服务器响应客户端请求的全过程称之为会话。会话跟踪指的是对同一个用户对服务器的连续的请求和接受响应的监视。会话跟踪常用的方法： i. url携带参数 ii. 隐藏表单域 iii. cookie iv. sessioncookie是可以被客户端禁用的，session的实现依赖cookie，如果cookie被禁用，session就会失效。 跨站攻击 123csrf 伪造用户请求， 可以通过检查reffer，token，验证码等方式避免xss 通过正常的交互将脚本嵌入页面，用户访问的时候即可启用。 https 12345678https又称HTTP over SSL 在http协议上增加了ssl https安全的基础是ssl - 对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全- 对网站服务器进行真实身份认证在交换密钥环节使用非对称加密方式解密证书（安全性高），之后的建立通信交换报文阶段则使用对称加密方式（解密效率高）。 缺点是 消耗资源较大和节省证书开销 spdy 123456多路复用：HTTP 1.x 在一条 TCP 连接上，多个请求只能串行执行。而 SPDY 使多个请求 stream 共享一个 TCP 连接的方式，做到了同时响应多个请求，解决了队头阻塞的问题。请求优先级header压缩服务端推送强制使用https http2.0 123456789101112131415多路复用压缩header服务端推送与spdy的区别：新的二进制格式支持明文传输header压缩方式不一样不强制使用https osi七层模型 1物理层-&gt;数据链路层-&gt;网络层-&gt;传输层-&gt;会话层-&gt;表示层-&gt;应用层 tcp/ip协议五层模型 1物理层-&gt;数据链路层-&gt;网络层-&gt;传输层-&gt;应用层 建立连接需要三次握手 四次挥手 1为什么不用两次，如果网络不好，报文因为时间太久已失效。如果不三次握手，那么服务端同意连接，那么连接就会被连接起来，但是客户端一直不发送消息过来，服务端资源就会被占用了。 tcp和udp的区别 12345678- TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接- TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保 证可靠交付- TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的- 每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信- TCP首部开销20字节;UDP的首部开销小，只有8个字节- TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道 什么叫syn攻击 1攻击客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送SYN包，服务器回复确认包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪。 SYN 攻击是一种典型的 DoS&#x2F;DDoS 攻击。 tcp 1234567- TCP 提供一种面向连接的、可靠的**字节流服务**- 在一个 TCP 连接中，仅有两方进行彼此通信。广播和多播不能用于 TCP- TCP 使用校验和，确认和重传机制来保证可靠传输- TCP 给数据分节进行排序，并使用累积确认保证数据的顺序不变和非重复- TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制keep-alive 是服务端每隔一段时间对客户端发一个检测包，如果收到ACK，则认为该链接还存活。类似soaagent的健康检查。由此引出小米网俄罗斯的问题。 udp 1234- udp不具有可靠性的数据报协议- udp是无连接的- udp的数据包是有边界的，且大小会随着数据包传过去的- 可以多播或者广播 keepalive和websocket 12345 keep-alive 只是一种为了达到复用tcp连接的“协商”行为，双方并没有建立正真的连接会话，服务端也可以不认可，也可以随时（在任何一次请求完成后）关闭掉。WebSocket 不同，它本身就规定了是正真的、双工的长连接，两边都必须要维持住连接的状态。keep-alive 一次 TCP 连接中完成多个 HTTP 请求，但是对每个请求仍然要单独发 headerwebsocket 通过第一个 HTTP request 建立了 TCP 连接之后，之后的交换数据都不需要再发 HTTP request了，使得这个长连接变成了一个真.长连接 tcp拥塞控制 123慢开始 拥塞避免快重传 快恢复 路由控制 123路由控制(Routing)是指将分组数据发送到目标地址的功能，这个功能一般由路由器完成如果路由形成一个环路。 子网掩码 rpc.grpc 名词 特点 RPC 远程过程调用（分布式、微服务间的方法调用） HTTP 无状态，每次请求都要发送一个request，服务器响应之后就断掉（http header中的keep-alive指的是tcp） TCP 面向连接，三次握手保证通信可靠 UDP 非面向连接，不可靠，速度快（可以手动对数据收发进行验证，IM系统多采用，QQ） socket TCP协议的接口实现，面向传输层进行网络编程 单独来谈一谈gRPCgRPC是谷歌开源的一个 RPC 框架，面向移动和 HTTP/2 设计。 内容交换格式采用ProtoBuf(Google Protocol Buffers)，开源已久，提供了一种灵活、高效、自动序列化结构数据的机制，作用与XML，Json类似，但使用二进制，（反）序列化速度快，压缩效率高。 传输协议 采用http2，性能比http1.1好了很多 thrift是Apache的一个跨语言的高性能的服务框架 这是一种描述语言，也是一个中间语言，IDL 一个使命就是规范和约束，规范使用类型，提供跨语言特性。通过工具分析 IDL 文件，生成各种语言代码 事实上的跨语言序列化方案只有三个： protobuf, thrift, json。 json体积太大，并且缺少类型信息，实际上只用在RESTful接口上，并没有看到RPC框架会默认选json做序列化的。 国内一些大公司的使用情况： protobuf ，腾迅，百度等 thrift，小米，美团等","tags":[{"name":"http","slug":"http","permalink":"http://lcf12307.github.io/tags/http/"},{"name":"网络","slug":"网络","permalink":"http://lcf12307.github.io/tags/%E7%BD%91%E7%BB%9C/"}]},{"title":"【第一课】缓存","date":"2019-11-04T16:00:00.000Z","path":"2019/11/05/面试/要点整理/缓存/","text":"本篇文章主要就redis的常见面试问题进行了讨论 为什么用redis？1因为传统的关系型数据库如Mysql已经不能适用所有的场景了，比如秒杀的库存扣减，APP首页的访问流量高峰等等，都很容易把数据库打崩，所以引入了缓存中间件，目前市面上比较常用的缓存中间件有 **Redis** 和 **Memcached** 不过中和考虑了他们的优缺点，最后选择了Redis。 redis和memecache的区别123456存储方式 Memecache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。Redis有部份存在硬盘上，这样能保证数据的持久性。数据支持类型 Memcache对数据类型支持相对简单。Redis有复杂的数据类型。redis的数据类型更多string,set,zset, list, hash, ， memcache只支持简单字符串使用底层模型不同 它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。value大小 redis最大可以达到1GB，而memcache只有1MBredis支持数据备份 即主从备份redis支持数据的持久化 可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。 为什么要用缓存？1对于一个服务其性能瓶颈往往都在DB，传统关系型存储尤甚。我们在创建表的时候，并不会未所有的字段创建索引，这意味着如果我们需要读取非缓存数据就要从磁盘拿数据。这个过程至少需要十几毫秒的时间。而缓存往往是基于内存的，这要比DB读数据快两个数量级。这是我们用缓存的根本原因原因。 缓存这么好，为什么不都用缓存1内存这东西虽然很快，同时它还很贵。动辄百十来G的数据都扔内存这有点太浪费。依据二八定律，我们只需找到那最紧俏的百分之二十就行了。这是非常重要的。否则你加了缓存效果反而更差。对于缓存有一个衡量指标，叫做缓存命中率。这个指标高说明我们请求的数据大部分来自缓存。证明我们加缓存这件事的收益越高。 缓存适用的场景123456会话缓存 如存储用户购物车中的数据的时候，利用redis持久化的特点，使其不会丢失数据。全页缓存 缓存页内数据队列 利用redis的list数据结构的push&#x2F;pop操作， 对数据进行操作排行榜 利用zset数据结构进行rank排行操作计数器 使用set来统计集合内的数据量订阅发布 利用订阅发布功能功能甚至可以搭建聊天室 缓存穿透12缓存穿透指的是如果我们访问一个缓存中没有的数据的时候就会去查询数据库， 如果数据库里也没有的话，一般是不更新缓存的， 这时候如果用户一直刷就会造成缓存穿透缓存空对象 或者缓存预测 缓存击穿12多个用户同时访问一个热点缓存，在这个key失效的瞬间 就会造成多次访问数据库， 造成缓存击穿。缓存预热 缓存加锁 缓存防雪崩12缓存服务暂时崩溃，导致大量请求访问数据库。采用高可用的缓存方案 限流 redis的新增数据结构123geo 地理索引 基于zsetHyperLogLog 寻找集合中的基数，即去重后的数据pub&#x2F;sub 发布订阅，如上文 如果有大量的key需要设置同一时间过期，一般需要注意什么？1如果我们过期时间设在同一时间，很有可能会造成缓存雪崩，大量访问指向数据库， 我们给定时时间一个随机值 那你使用过Redis分布式锁么，它是什么回事？1先使用setnx争抢锁 用expire给这个key添加过期时间，防止忘记释放。 然后接着问如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？1这时候这个锁就永远无法释放了。 可以通过set里的nx,ex两个命令行参数来进行原子化操作。 假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？1使用keys命令可以扫出制定模式的 如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？1redis是单线程的，线上会停顿，直到这个指令结束。 使用scan可以无阻塞的提出指定模式的keys，但是可能会重复 使用redis怎么实现异步队列？1使用list数据类型， rpush 发送消息， lpop接收消息， 接收不到消息的时候适当的sleep一段时间 可不可以不用sleep1list有个指令 blpop 可以在消息不来的时候阻塞住知道消息到来 能不能一次生产 多次消费1使用pub&#x2F;sub模式，可以实现1:n的消息队列 pub/sub有什么缺点1一旦消费者下线， 消息就会丢失。 建议还是使用专业的消息队列， \\**RocketMQ rabbitmq\\* Redis如何实现延时队列？1使用zset 值为时间戳 key为消息内容 使用zadd添加消息 使用zrangebyscore获取n秒前的数据。 redis怎么持久化的 主从数据怎么进行交互？1rdb进行镜像全量同步， aof做增量持久化。 因为rdb耗费时间较久 需要配合aof来使用。 当redis重启时， 使用rdb持久化文件重新构建内存， 再用aof重放近期的操作指令来恢复重启前的状态 突然停电怎么办1取决于 aof的sync配置，如果不考虑性能的话每条指令后都sync下就不会丢失，但是一般来说，不会这么配置，如果配置每秒同步一次的话，丢失的就是这一秒的数据 rdb的原理1234567891011fork 和 cow 父进程fork一个子进程，并且开始进行rdb， 子进程创建后，父子共享数据段， 父进程继续进行读写操作。redis每隔几分钟形成一个快照- rdb保存了redis某个时间点的数据集合， 体积较小适合用于灾难回复 恢复大量数据的时候比aof快 但是会丢失数据- aof同步频率快且不影响redis性能。有序追加对redis的操作指令但是体积较大 Pipline的好处是什么1可以把多次io缩减为1次 redis的同步机制1主从同步和从从同步， 主节点做一次bgsave，生成rdb镜像， 并保存后续的操作记录。 待完成后，主节点把rdb全量同步给复制节点， 复制节点加载完rdb后， 增量数据使用aof同步。 redis集群的高可用怎么保证， 原理是什么12Redis Sentinal 着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。 Redis Cluster 着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。 pika和redis12345678910111213141516171819202122232425262728pika相对于redis，最大的不同就是pika是持久化存储，数据存在磁盘上，而redis是内存存储，由此不同也给pika带来了相对于redis的优势和劣势**大容量redis 遇到的问题- 恢复时间长- 一主多从, 主从切换代价大- 缓冲区写满问题- 内存太贵Pika的特点1. 容量大，支持百G数据量的存储2. 兼容Redis，不用修改代码即可平滑从Redis迁移到Pika3. 支持主从(slaveof)4. 完善的运维命令优势:- 容量大：Pika没有Redis的内存限制, 最大使用空间等于磁盘空间的大小**- 加载db速度快：Pika 在写入的时候, 数据是落盘的, 所以即使节点挂了, 不需要rbd或者aof，pika 重启不用重新加载数据到内存而是直接使用已经持久化在磁盘上的数据, 不需要任何数据回放操作，这大大降低了重启成本。**- 备份速度快：Pika备份的速度大致等同于cp的速度（拷贝数据文件后还有一个快照的恢复过程，会花费一些时间），这样在对于百G大库的备份是快捷的，更快的备份速度更好的解决了主从的全同步问题劣势：由于Pika是基于内存和文件来存放数据, 所以性能肯定比Redis低一些, 但是我们一般使用SSD盘来存放数据, 尽可能跟上Redis的性能。从以上的对比可以看出, 如果你的业务场景的数据比较大，Redis 很难支撑， 比如大于50G，或者你的数据很重要，不允许断电丢失，那么使用Pika 就可以解决你的问题。而在实际使用中，大多数场景下pika的性能大约是Redis的50%~80%，在某些特定场景下，例如range 500，pika的性能只有redis的20%，针对这些场景我们仍然在改进 从pika迁移到pika12345 DBA需要做的1. DBA迁移Redis数据到Pika2. DBA将Redis的数据实时同步到Pika，确保Redis与Pika的数据始终一致3. DBA切换LVS后端ip，由Pika替换Redis redis数据过期的问题123456在单机版Redis中，存在两种删除策略：- 惰性删除：服务器不会主动删除数据，只有当客户端查询某个数据时，服务器判断该数据是否过期，如果过期则删除。- 定期删除：服务器执行定时任务删除过期数据，但是考虑到内存和CPU的折中（删除会释放内存，但是频繁的删除操作对CPU不友好），该删除的频率和执行时间都受到了限制。在主从复制场景下，为了主从节点的数据一致性，从节点不会主动删除数据，而是由主节点控制从节点中过期数据的删除。由于主节点的惰性删除和定期删除策略，都不能保证主节点及时对过期数据执行删除操作，因此，当客户端通过Redis从节点读取数据时，很容易读取到已经过期的数据。 如果定期删除漏掉了很多过期 key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期 key 堆积在内存里，导致 redis 内存块耗尽了，咋整？12345678910内存淘汰机制。redis 内存淘汰机制有以下几个：- noeviction: 当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用吧，实在是太恶心了。- allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）。- allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个 key，这个一般没人用吧，为啥要随机，肯定是把最近最少使用的 key 给干掉啊。- volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 key（这个一般不太合适）。- volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 key。- volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 key 优先移除。 实现lru12345使用链表来实现， 当命中某个值的时候 把它移到链表头部， 淘汰尾部lru-k 使用两个队列，一个是访问历史队列，先进先出一个lru队列 哨兵机制12345678为了解决redis主从复制模式致命缺点，当主节点宕机，影响整个系统运行，引入哨兵机制Sentinel。Sentinel哨兵主要解决以下问题：- 监控，监控每个节点以及哨兵运行状态- 报警，当发现某个节点或哨兵出现问题，通知其他哨兵- 自动故障转化，当主节点宕机时，哨兵从原主节点下的所有可用从节点中选举出一个作为主节点，原主节点降为从节点，并将其他从节点的主节点配置改为指定新主节点- 配置中心，客户端初始化连接的是哨兵节点集合","tags":[{"name":"redis","slug":"redis","permalink":"http://lcf12307.github.io/tags/redis/"},{"name":"memcache","slug":"memcache","permalink":"http://lcf12307.github.io/tags/memcache/"},{"name":"缓存","slug":"缓存","permalink":"http://lcf12307.github.io/tags/%E7%BC%93%E5%AD%98/"}]},{"title":"【常见问题】wine下的应用无法输入中文，解决办法","date":"2019-07-21T06:51:25.000Z","path":"2019/07/21/常见问题/wine应用无法输入中文/","text":"因为工作环境是linux，免不了用wine装微信等工具，但是支持不了中文，因此进行一下调研 我用的搜狗输入法，属于fcitx框架。桌面是gnome3。 解决方法： 1、尝试设置环境变量 export GTK_IM_MODULE=fcitxexport QT_IM_MODULE=fcitxexport XMODIFIERS=”@im=fcitx”设置完后，尝试在当前终端下，用wine启动程序试试，如果可以就是环境变量的问题 2、尝试以下命令 gsettings set org.gnome.settings-daemon.plugins.keyboard active false3、以上都不好使的情况下，放大招（偶然发现，我就是这么搞定的） 用wine打开程序后，发现不能正确切换到输入法，此时请重启fcitx服务，重启后，意外发现wine打开的程序中可以使用输入法了。而且执行一次后，后续用wine启动其他应用，都可以正常输入，好神奇。","tags":[{"name":"php","slug":"php","permalink":"http://lcf12307.github.io/tags/php/"},{"name":"服务器","slug":"服务器","permalink":"http://lcf12307.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]},{"title":"bash快捷键","date":"2019-04-23T16:00:00.000Z","path":"2019/04/24/常见问题/云服务器/bash快捷键/","text":"今天敲命令行时想在单词间移动，竟然不记得快速移动的快捷键。试了Ctrl + W和Ctrl + B/F均不凑效，于是怀念之前某博主分享的终端快捷键说明图。 好在很快从浏览记录中找到了链接。原博主(@linuxtoy)分享的终端跳转解说图为： 虽然命令难记，但解说图清晰易懂，让人印象深刻。 趁热打铁，马上找了篇解说bash快捷键的文章温习一下。博主Alan Skorkin的”Bash Shortcuts For Maximum Productivity“一文写得十分详细，故在此翻译和分享，并部分内容做注释和修正。 Alan Skorkin将bash快捷键分成四类，接下来一一给出。 编辑 Ctrl + a – 跳到行首 Ctrl + e – 跳到行尾 Ctrl + k – 删除当前光标至行尾内容 Ctrl + u – 删除当前光标至行首内容 Ctrl + w – 删除当前光标至词首内容 Ctrl + y – 将剪切的内容粘贴在光标后 Ctrl + xx – 在行首和当前光标处(来回)移动 Alt + b – 跳到词首 Alt + f – 跳到词尾 Alt + d – 删除自光标处起的单词内容 Alt + c – 大写光标处的字符（注：该条内容与原文不同） Alt + u – 大写自光标处起的单词内容 Alt + l – 小写自光标处起的单词内容 Alt + t – 将光标处单词与上一个词交换 Ctrl + f – 向前移动一个字符(相当于按向左箭头) Ctrl + b – 向后移动一个字符(相当于按向右箭头) Ctrl + d – 删除光标后一个字符（相当于按Delete） Ctrl + h – 删除光标前一个字符（相当于按后退键） Ctrl + t – 交换光标处的两个字符 搜索 Ctrl + r – 反向搜索历史命令 Ctrl + g – 退出历史搜索模式（相当于按Esc） Ctrl + p – 上一个历史命令（相当于按向上箭头） Ctrl + n – 下一个历史命令（相当于按向下箭头） Alt + . – 使用上一个命令的最后一个单词 控制 Ctrl + l – 清屏 Ctrl + s – 终止输出到屏幕（对长时间运行并打印详细信息的命令） Ctrl + q – 允许输出到屏幕（如果之前用过终止输出命令） Ctrl + c – 终止命令 Ctrl + z – 中断命令 Bang(即感叹号) !! – 执行上一条命令 !blah –执行最近运行过的以blah开头的命令 !blah:p – 打印!blah要执行的命令（并将其作为最后一条命令加入到命令历史中） !$ – 上一条命令的最后一个单词 (等同于Alt + .) !$:p – 打印!$指代的单词 !* – 上一条命令除最后一个词的部分 !*:p – 打印!*指代部分 如果错误，敬请指正！","tags":[{"name":"linux","slug":"linux","permalink":"http://lcf12307.github.io/tags/linux/"},{"name":"快捷键","slug":"快捷键","permalink":"http://lcf12307.github.io/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"name":"云服务器","slug":"云服务器","permalink":"http://lcf12307.github.io/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]},{"title":"vim快捷键","date":"2019-04-23T16:00:00.000Z","path":"2019/04/24/常见问题/云服务器/vim快捷键/","text":"经使用了两年多的Vim，手册也翻过一遍。虽然现在不怎么用vim了，曾经的笔记还是贴出来，与喜欢vim的朋友分享。 1. 关于Vimvim是我最喜欢的编辑器，也是linux下第二强大的编辑器。 虽然emacs是公认的世界第一，我认为使用emacs并没有使用vi进行编辑来得高效。 如果是初学vi，运行一下vimtutor是个聪明的决定。 （如果你的系统环境不是中文，而你想使用中文的vimtutor，就运行vimtutor zh） 1.1 Vim的几种模式 正常模式：可以使用快捷键命令，或按:输入命令行。 插入模式：可以输入文本，在正常模式下，按i、a、o等都可以进入插入模式。 可视模式：正常模式下按v可以进入可视模式， 在可视模式下，移动光标可以选择文本。按V进入可视行模式， 总是整行整行的选中。ctrl+v进入可视块模式。 替换模式：正常模式下，按R进入。 2. 启动Vim vim -c cmd file: 在打开文件前，先执行指定的命令； vim -r file: 恢复上次异常退出的文件； vim -R file: 以只读的方式打开文件，但可以强制保存； vim -M file: 以只读的方式打开文件，不可以强制保存； vim -y num file: 将编辑窗口的大小设为num行； vim + file: 从文件的末尾开始； vim +num file: 从第num行开始； vim +/string file: 打开file，并将光标停留在第一个找到的string上。 vim –remote file: 用已有的vim进程打开指定的文件。 如果你不想启用多个vim会话，这个很有用。但要注意， 如果你用vim，会寻找名叫VIM的服务器；如果你已经有一个gvim在运行了， 你可以用gvim –remote file在已有的gvim中打开文件。 3. 文档操作 :e file –关闭当前编辑的文件，并开启新的文件。 如果对当前文件的修改未保存，vi会警告。 :e! file –放弃对当前文件的修改，编辑新的文件。 :e+file – 开始新的文件，并从文件尾开始编辑。 :e+n file – 开始新的文件，并从第n行开始编辑。 :enew –编译一个未命名的新文档。(CTRL-W n) :e – 重新加载当前文档。 :e! – 重新加载当前文档，并丢弃已做的改动。 :e#或ctrl+^ – 回到刚才编辑的文件，很实用。 :f或ctrl+g – 显示文档名，是否修改，和光标位置。 :f filename – 改变编辑的文件名，这时再保存相当于另存为。 gf – 打开以光标所在字符串为文件名的文件。 :w – 保存修改。 :n1,n2w filename – 选择性保存从某n1行到另n2行的内容。 :wq – 保存并退出。 ZZ – 保存并退出。 :x – 保存并退出。 :q[uit] ——退出当前窗口。(CTRL-W q或CTRL-W CTRL-Q) :saveas newfilename – 另存为 :browse e – 会打开一个文件浏览器让你选择要编辑的文件。 如果是终端中，则会打开netrw的文件浏览窗口； 如果是gvim，则会打开一个图形界面的浏览窗口。 实际上:browse后可以跟任何编辑文档的命令，如sp等。 用browse打开的起始目录可以由browsedir来设置： :set browsedir=last – 用上次访问过的目录（默认）； :set browsedir=buffer – 用当前文件所在目录； :set browsedir=current – 用当前工作目录； :Sex – 水平分割一个窗口，浏览文件系统； :Vex – 垂直分割一个窗口，浏览文件系统； 4. 光标的移动4.1 基本移动以下移动都是在normal模式下。 h或退格: 左移一个字符； l或空格: 右移一个字符； j: 下移一行； k: 上移一行； gj: 移动到一段内的下一行； gk: 移动到一段内的上一行； +或Enter: 把光标移至下一行第一个非空白字符。 -: 把光标移至上一行第一个非空白字符。 w: 前移一个单词，光标停在下一个单词开头； W: 移动下一个单词开头，但忽略一些标点； e: 前移一个单词，光标停在下一个单词末尾； E: 移动到下一个单词末尾，如果词尾有标点，则移动到标点； b: 后移一个单词，光标停在上一个单词开头； B: 移动到上一个单词开头，忽略一些标点； ge: 后移一个单词，光标停在上一个单词末尾； gE: 同 ge ，不过‘单词’包含单词相邻的标点。 (: 前移1句。 ): 后移1句。 {: 前移1段。 }: 后移1段。 fc: 把光标移到同一行的下一个c字符处 Fc: 把光标移到同一行的上一个c字符处 tc: 把光标移到同一行的下一个c字符前 Tc: 把光标移到同一行的上一个c字符后 ;: 配合f &amp; t使用，重复一次 ,: 配合f &amp; t使用，反向重复一次 上面的操作都可以配合n使用，比如在正常模式(下面会讲到)下输入3h， 则光标向左移动3个字符。 0: 移动到行首。 g0: 移到光标所在屏幕行行首。 ^: 移动到本行第一个非空白字符。 g^: 同 ^ ，但是移动到当前屏幕行第一个非空字符处。 $: 移动到行尾。 g$: 移动光标所在屏幕行行尾。 n|: 把光标移到递n列上。 nG: 到文件第n行。 :n 移动到第n行。 :$ 移动到最后一行。 H: 把光标移到屏幕最顶端一行。 M: 把光标移到屏幕中间一行。 L: 把光标移到屏幕最底端一行。 gg: 到文件头部。 G: 到文件尾部。 4.2 翻屏 ctrl+f: 下翻一屏。 ctrl+b: 上翻一屏。 ctrl+d: 下翻半屏。 ctrl+u: 上翻半屏。 ctrl+e: 向下滚动一行。 ctrl+y: 向上滚动一行。 n%: 到文件n%的位置。 zz: 将当前行移动到屏幕中央。 zt: 将当前行移动到屏幕顶端。 zb: 将当前行移动到屏幕底端。 4.3 标记使用标记可以快速移动。到达标记后，可以用Ctrl+o返回原来的位置。 Ctrl+o和Ctrl+i 很像浏览器上的 后退 和 前进 。 m{a-z}: 标记光标所在位置，局部标记，只用于当前文件。 m{A-Z}: 标记光标所在位置，全局标记。标记之后，退出Vim， 重新启动，标记仍然有效。 `{a-z}: 移动到标记位置。 ‘{a-z}: 移动到标记行的行首。 `{0-9}：回到上[2-10]次关闭vim时最后离开的位置。 : 移动到上次编辑的位置。&#39;&#39;也可以，不过精确到列，而’’精确到行 。如果想跳转到更老的位置，可以按C-o，跳转到更新的位置用C-i。 `”: 移动到上次离开的地方。 `.: 移动到最后改动的地方。 :marks 显示所有标记。 :delmarks a b – 删除标记a和b。 :delmarks a-c – 删除标记a、b和c。 :delmarks a c-f – 删除标记a、c、d、e、f。 :delmarks! – 删除当前缓冲区的所有标记。 :help mark-motions 查看更多关于mark的知识。 5. 插入文本5.1 基本插入 i: 在光标前插入；一个小技巧：按8，再按i，进入插入模式，输入=， 按esc进入命令模式，就会出现8个=。 这在插入分割线时非常有用，如30i+就插入了36个+组成的分割线。 I: 在当前行第一个非空字符前插入； gI: 在当前行第一列插入； a: 在光标后插入； A: 在当前行最后插入； o: 在下面新建一行插入； O: 在上面新建一行插入； :r filename在当前位置插入另一个文件的内容。 :[n]r filename在第n行插入另一个文件的内容。 :r !date 在光标处插入当前日期与时间。同理，:r !command可以将其它shell命令的输出插入当前文档。 5.2 改写插入 c[n]w: 改写光标后1(n)个词。 c[n]l: 改写光标后n个字母。 c[n]h: 改写光标前n个字母。 [n]cc: 修改当前[n]行。 [n]s: 以输入的文本替代光标之后1(n)个字符，相当于c[n]l。 [n]S: 删除指定数目的行，并以所输入文本代替之。 注意，类似cnw,dnw,ynw的形式同样可以写为ncw,ndw,nyw。 6. 剪切复制和寄存器6.1 剪切和复制、粘贴 [n]x: 剪切光标右边n个字符，相当于d[n]l。 [n]X: 剪切光标左边n个字符，相当于d[n]h。 y: 复制在可视模式下选中的文本。 yy or Y: 复制整行文本。 y[n]w: 复制一(n)个词。 y[n]l: 复制光标右边1(n)个字符。 y[n]h: 复制光标左边1(n)个字符。 y$: 从光标当前位置复制到行尾。 y0: 从光标当前位置复制到行首。 :m,ny 复制m行到n行的内容。 y1G或ygg: 复制光标以上的所有行。 yG: 复制光标以下的所有行。 yaw和yas：复制一个词和复制一个句子，即使光标不在词首和句首也没关系。 d: 删除（剪切）在可视模式下选中的文本。 d$ or D: 删除（剪切）当前位置到行尾的内容。 d[n]w: 删除（剪切）1(n)个单词 d[n]l: 删除（剪切）光标右边1(n)个字符。 d[n]h: 删除（剪切）光标左边1(n)个字符。 d0: 删除（剪切）当前位置到行首的内容 [n] dd: 删除（剪切）1(n)行。 :m,nd 剪切m行到n行的内容。 d1G或dgg: 剪切光标以上的所有行。 dG: 剪切光标以下的所有行。 daw和das：剪切一个词和剪切一个句子，即使光标不在词首和句首也没关系。 d/f：这是一个比较高级的组合命令，它将删除当前位置 到下一个f之间的内容。 p: 在光标之后粘贴。 P: 在光标之前粘贴。 6.2 文本对象 aw：一个词 as：一句。 ap：一段。 ab：一块（包含在圆括号中的）。 y, d, c, v都可以跟文本对象。 6.3 寄存器 a-z：都可以用作寄存器名。”ayy把当前行的内容放入a寄存器。 A-Z：用大写字母索引寄存器，可以在寄存器中追加内容。 如”Ayy把当前行的内容追加到a寄存器中。 :reg 显示所有寄存器的内容。 “”：不加寄存器索引时，默认使用的寄存器。 “：当前选择缓冲区，”yy把当前行的内容放入当前选择缓冲区。 “+：系统剪贴板。”+yy把当前行的内容放入系统剪贴板。 7. 查找与替换7.1 查找 /something: 在后面的文本中查找something。 ?something: 在前面的文本中查找something。 /pattern/+number: 将光标停在包含pattern的行后面第number行上。 /pattern/-number: 将光标停在包含pattern的行前面第number行上。 n: 向后查找下一个。 N: 向前查找下一个。 可以用grep或vimgrep查找一个模式都在哪些地方出现过， 其中:grep是调用外部的grep程序，而:vimgrep是vim自己的查找算法。 用法为： :vim[grep]/pattern/[g] [j] files g的含义是如果一个模式在一行中多次出现，则这一行也在结果中多次出现。 j的含义是grep结束后，结果停在第j项，默认是停在第一项。 vimgrep前面可以加数字限定搜索结果的上限，如 :1vim/pattern/ % 只查找那个模式在本文件中的第一个出现。 其实vimgrep在读纯文本电子书时特别有用，可以生成导航的目录。 比如电子书中每一节的标题形式为：n. xxxx。你就可以这样： :vim/^d{1,}./ % 然后用:cw或:copen查看结果，可以用C-w H把quickfix窗口移到左侧， 就更像个目录了。 7.2 替换 :s/old/new - 用new替换当前行第一个old。 :s/old/new/g - 用new替换当前行所有的old。 :n1,n2s/old/new/g - 用new替换文件n1行到n2行所有的old。 :%s/old/new/g - 用new替换文件中所有的old。 :%s/^/xxx/g - 在每一行的行首插入xxx，^表示行首。 :%s/$/xxx/g - 在每一行的行尾插入xxx，$表示行尾。 所有替换命令末尾加上c，每个替换都将需要用户确认。 如：%s/old/new/gc，加上i则忽略大小写(ignore)。 还有一种比替换更灵活的方式，它是匹配到某个模式后执行某种命令， 语法为 :[range]g/pattern/command 例如 :%g/^ xyz/normal dd。 表示对于以一个空格和xyz开头的行执行normal模式下的dd命令。 关于range的规定为： 如果不指定range，则表示当前行。 m,n: 从m行到n行。 0: 最开始一行（可能是这样）。 $: 最后一行 .: 当前行 %: 所有行 7.3 正则表达式高级的查找替换就要用到正则表达式。 \\d: 表示十进制数（我猜的） \\s: 表示空格 \\S: 非空字符 \\a: 英文字母 |: 表示 或 .: 表示. {m,n}: 表示m到n个字符。这要和 \\s与\\a等连用，如 \\a{m,n} 表示m 到n个英文字母。 {m,}: 表示m到无限多个字符。 **: 当前目录下的所有子目录。 :help pattern得到更多帮助。 8. 排版8.1 基本排版 &lt;&lt; 向左缩进一个shiftwidth &gt;&gt; 向右缩进一个shiftwidth :ce(nter) 本行文字居中 :le(ft) 本行文字靠左 :ri(ght) 本行文字靠右 gq 对选中的文字重排，即对过长的文字进行断行 gqq 重排当前行 gqnq 重排n行 gqap 重排当前段 gqnap 重排n段 gqnj 重排当前行和下面n行 gqQ 重排当前段对文章末尾 J 拼接当前行和下一行 gJ 同 J ，不过合并后不留空格。 8.2 拼写检查 :set spell－开启拼写检查功能 :set nospell－关闭拼写检查功能 ]s－移到下一个拼写错误的单词 [s－作用与上一命令类似，但它是从相反方向进行搜索 z=－显示一个有关拼写错误单词的列表，可从中选择 zg－告诉拼写检查器该单词是拼写正确的 zw－与上一命令相反，告诉拼写检查器该单词是拼写错误的 8.3 统计字数g ^g可以统计文档字符数，行数。 将光标放在最后一个字符上，用字符数减去行数可以粗略统计中文文档的字数。 以上对 Mac 或 Unix 的文件格式适用。 如果是 Windows 文件格式（即换行符有两个字节），字数的统计方法为： 字符数 - 行数 * 2。 9. 编辑多个文件9.1 一次编辑多个文件我们可以一次打开多个文件，如 1vi a.txt b.txt c.txt 使用:next(:n)编辑下一个文件。 :2n 编辑下2个文件。 使用:previous或:N编辑上一个文件。 使用:wnext，保存当前文件，并编辑下一个文件。 使用:wprevious，保存当前文件，并编辑上一个文件。 使用:args 显示文件列表。 :n filenames或:args filenames 指定新的文件列表。 vi -o filenames 在水平分割的多个窗口中编辑多个文件。 vi -O filenames 在垂直分割的多个窗口中编辑多个文件。 9.2 多标签编辑 vim -p files: 打开多个文件，每个文件占用一个标签页。 :tabe, tabnew – 如果加文件名，就在新的标签中打开这个文件， 否则打开一个空缓冲区。 ^w gf – 在新的标签页里打开光标下路径指定的文件。 :tabn – 切换到下一个标签。Control + PageDown，也可以。 :tabp – 切换到上一个标签。Control + PageUp，也可以。 [n] gt – 切换到下一个标签。如果前面加了 n ， 就切换到第n个标签。第一个标签的序号就是1。 :tab split – 将当前缓冲区的内容在新页签中打开。 :tabc[lose] – 关闭当前的标签页。 :tabo[nly] – 关闭其它的标签页。 :tabs – 列出所有的标签页和它们包含的窗口。 :tabm[ove] [N] – 移动标签页，移动到第N个标签页之后。 如 tabm 0 当前标签页，就会变成第一个标签页。 9.3 缓冲区 :buffers或:ls或:files 显示缓冲区列表。 ctrl+^：在最近两个缓冲区间切换。 :bn – 下一个缓冲区。 :bp – 上一个缓冲区。 :bl – 最后一个缓冲区。 :b[n]或:[n]b – 切换到第n个缓冲区。 :nbw(ipeout) – 彻底删除第n个缓冲区。 :nbd(elete) – 删除第n个缓冲区，并未真正删除，还在unlisted列表中。 :ba[ll] – 把所有的缓冲区在当前页中打开，每个缓冲区占一个窗口。 10. 分屏编辑 vim -o file1 file2:水平分割窗口，同时打开file1和file2 vim -O file1 file2:垂直分割窗口，同时打开file1和file2 10.1 水平分割 :split(:sp) – 把当前窗水平分割成两个窗口。(CTRL-W s 或 CTRL-W CTRL-S) 注意如果在终端下，CTRL-S可能会冻结终端，请按CTRL-Q继续。 :split filename – 水平分割窗口，并在新窗口中显示另一个文件。 :nsplit(:nsp) – 水平分割出一个n行高的窗口。 :[N]new – 水平分割出一个N行高的窗口，并编辑一个新文件。 (CTRL-W n或 CTRL-W CTRL-N) ctrl+w f –水平分割出一个窗口，并在新窗口打开名称为光标所在词的文件 。 C-w C-^ – 水平分割一个窗口，打开刚才编辑的文件。 10.2 垂直分割 :vsplit(:vsp) – 把当前窗口分割成水平分布的两个窗口。 (CTRL-W v或CTRL CTRL-V) :[N]vne[w] – 垂直分割出一个新窗口。 :vertical 水平分割的命令： 相应的垂直分割。 10.3 关闭子窗口 :qall – 关闭所有窗口，退出vim。 :wall – 保存所有修改过的窗口。 :only – 只保留当前窗口，关闭其它窗口。(CTRL-W o) :close – 关闭当前窗口，CTRL-W c能实现同样的功能。 (象 :q :x同样工作 ) 10.4 调整窗口大小 ctrl+w + –当前窗口增高一行。也可以用n增高n行。 ctrl+w - –当前窗口减小一行。也可以用n减小n行。 ctrl+w _ –当前窗口扩展到尽可能的大。也可以用n设定行数。 :resize n – 当前窗口n行高。 ctrl+w = – 所有窗口同样高度。 n ctrl+w _ – 当前窗口的高度设定为n行。 ctrl+w &lt; –当前窗口减少一列。也可以用n减少n列。 ctrl+w &gt; –当前窗口增宽一列。也可以用n增宽n列。 ctrl+w | –当前窗口尽可能的宽。也可以用n设定列数。 10.5 切换和移动窗口如果支持鼠标，切换和调整子窗口的大小就简单了。 ctrl+w ctrl+w: 切换到下一个窗口。或者是ctrl+w w。 ctrl+w p: 切换到前一个窗口。 ctrl+w h(l,j,k):切换到左（右，下，上）的窗口。 ctrl+w t(b):切换到最上（下）面的窗口。 ctrl+w H(L,K,J): 将当前窗口移动到最左（右、上、下）面。 ctrl+w r：旋转窗口的位置。 ctrl+w T: 将当前的窗口移动到新的标签页上。 11. 快速编辑11.1 改变大小写 ~: 反转光标所在字符的大小写。 可视模式下的U或u：把选中的文本变为大写或小写。 gu(U)接范围（如$，或G），可以把从光标当前位置到指定位置之间字母全部 转换成小写或大写。如ggguG，就是把开头到最后一行之间的字母全部变为小 写。再如gu5j，把当前行和下面四行全部变成小写。 11.2 替换（normal模式） r: 替换光标处的字符，同样支持汉字。 R: 进入替换模式，按esc回到正常模式。 11.3 撤消与重做（normal模式） [n] u: 取消一(n)个改动。 :undo 5 – 撤销5个改变。 :undolist – 你的撤销历史。 ctrl + r: 重做最后的改动。 U: 取消当前行中所有的改动。 :earlier 4m – 回到4分钟前 :later 55s – 前进55秒 11.4 宏 . –重复上一个编辑动作 qa：开始录制宏a（键盘操作记录） q：停止录制 @a：播放宏a 12. 编辑特殊文件12.1 文件加解密 vim -x file: 开始编辑一个加密的文件。 :X – 为当前文件设置密码。 :set key= – 去除文件的密码。 这里是 滇狐总结的比较高级的vi技巧。 12.2 文件的编码 :e ++enc=utf8 filename, 让vim用utf-8的编码打开这个文件。 :w ++enc=gbk，不管当前文件什么编码，把它转存成gbk编码。 :set fenc或:set fileencoding，查看当前文件的编码。 在vimrc中添加set fileencoding=ucs-bom,utf-8,cp936，vim会根据要打开的文件选择合适的编码。 注意：编码之间不要留空格。 cp936对应于gbk编码。 ucs-bom对应于windows下的文件格式。 让vim 正确处理文件格式和文件编码，有赖于 ~/.vimrc的正确配置 12.3 文件格式大致有三种文件格式：unix, dos, mac. 三种格式的区别主要在于回车键的编码：dos 下是回车加换行，unix 下只有 换行符，mac 下只有回车符。 :e ++ff=dos filename, 让vim用dos格式打开这个文件。 :w ++ff=mac filename, 以mac格式存储这个文件。 :set ff，显示当前文件的格式。 在vimrc中添加set fileformats=unix,dos,mac，让vim自动识别文件格式。 13. 编程辅助13.1 一些按键 gd: 跳转到局部变量的定义处； gD: 跳转到全局变量的定义处，从当前文件开头开始搜索； g;: 上一个修改过的地方； g,: 下一个修改过的地方； [[: 跳转到上一个函数块开始，需要有单独一行的{。 ]]: 跳转到下一个函数块开始，需要有单独一行的{。 []: 跳转到上一个函数块结束，需要有单独一行的}。 ][: 跳转到下一个函数块结束，需要有单独一行的}。 [{: 跳转到当前块开始处； ]}: 跳转到当前块结束处； [/: 跳转到当前注释块开始处； ]/: 跳转到当前注释块结束处； %: 不仅能移动到匹配的(),{}或[]上，而且能在#if，#else， #endif之间跳跃。 下面的括号匹配对编程很实用的。 ci’, di’, yi’：修改、剪切或复制’之间的内容。 ca’, da’, ya’：修改、剪切或复制’之间的内容，包含’。 ci”, di”, yi”：修改、剪切或复制”之间的内容。 ca”, da”, ya”：修改、剪切或复制”之间的内容，包含”。 ci(, di(, yi(：修改、剪切或复制()之间的内容。 ca(, da(, ya(：修改、剪切或复制()之间的内容，包含()。 ci[, di[, yi[：修改、剪切或复制[]之间的内容。 ca[, da[, ya[：修改、剪切或复制[]之间的内容，包含[]。 ci{, di{, yi{：修改、剪切或复制{}之间的内容。 ca{, da{, ya{：修改、剪切或复制{}之间的内容，包含{}。 ci&lt;, di&lt;, yi&lt;：修改、剪切或复制&lt;&gt;之间的内容。 ca&lt;, da&lt;, ya&lt;：修改、剪切或复制&lt;&gt;之间的内容，包含&lt;&gt;。 13.2 ctags ctags -R: 生成tag文件，-R表示也为子目录中的文件生成tags :set tags=path/tags – 告诉ctags使用哪个tag文件 :tag xyz – 跳到xyz的定义处，或者将光标放在xyz上按C-]，返回用C-t :stag xyz – 用分割的窗口显示xyz的定义，或者C-w ]， 如果用C-w n ]，就会打开一个n行高的窗口 :ptag xyz – 在预览窗口中打开xyz的定义，热键是C-w }。 :pclose – 关闭预览窗口。热键是C-w z。 :pedit abc.h – 在预览窗口中编辑abc.h :psearch abc – 搜索当前文件和当前文件include的文件，显示包含abc的行。 有时一个tag可能有多个匹配，如函数重载，一个函数名就会有多个匹配。 这种情况会先跳转到第一个匹配处。 :[n]tnext – 下一[n]个匹配。 :[n]tprev – 上一[n]个匹配。 :tfirst – 第一个匹配 :tlast – 最后一个匹配 :tselect tagname – 打开选择列表 tab键补齐 :tag xyz – 补齐以xyz开头的tag名，继续按tab键，会显示其他的。 :tag /xyz – 会用名字中含有xyz的tag名补全。 13.3 cscope cscope -Rbq: 生成cscope.out文件 :cs add /path/to/cscope.out /your/work/dir :cs find c func – 查找func在哪些地方被调用 :cw – 打开quickfix窗口查看结果 13.4 gtagsGtags综合了ctags和cscope的功能。 使用Gtags之前，你需要安装GNU Gtags。 然后在工程目录运行 gtags 。 :Gtags funcname 定位到 funcname 的定义处。 :Gtags -r funcname 查询 funcname被引用的地方。 :Gtags -s symbol 定位 symbol 出现的地方。 :Gtags -g string Goto string 出现的地方。 :Gtags -gi string 忽略大小写。 :Gtags -f filename 显示 filename 中的函数列表。 你可以用 :Gtags -f % 显示当前文件。 :Gtags -P pattern 显示路径中包含特定模式的文件。 如 :Gtags -P .h$ 显示所有头文件， :Gtags -P /vm/ 显示vm目录下的文件。 13.5 编译vim提供了:make来编译程序，默认调用的是make， 如果你当前目录下有makefile，简单地:make即可。 如果你没有make程序，你可以通过配置makeprg选项来更改make调用的程序。 如果你只有一个abc.java文件，你可以这样设置： 1set makeprg&#x3D;javac\\ abc.java 然后:make即可。如果程序有错，可以通过quickfix窗口查看错误。 不过如果要正确定位错误，需要设置好errorformat，让vim识别错误信息。 如： 1:setl efm&#x3D;%A%f:%l:\\ %m,%-Z%p^,%-C%.%# %f表示文件名，%l表示行号， %m表示错误信息，其它的还不能理解。 请参考 :help errorformat。 13.6 快速修改窗口其实是quickfix插件提供的功能， 对编译调试程序非常有用 :) :copen – 打开快速修改窗口。 :cclose – 关闭快速修改窗口。 快速修改窗口在make程序时非常有用，当make之后： :cl – 在快速修改窗口中列出错误。 :cn – 定位到下一个错误。 :cp – 定位到上一个错误。 :cr – 定位到第一个错误。 13.7 自动补全 C-x C-s – 拼写建议。 C-x C-v – 补全vim选项和命令。 C-x C-l – 整行补全。 C-x C-f – 自动补全文件路径。弹出菜单后，按C-f循环选择，当然也可以按 C-n和C-p。 C-x C-p 和C-x C-n – 用文档中出现过的单词补全当前的词。 直接按C-p和C-n也可以。 C-x C-o – 编程时可以补全关键字和函数名啊。 C-x C-i – 根据头文件内关键字补全。 C-x C-d – 补全宏定义。 C-x C-n – 按缓冲区中出现过的关键字补全。 直接按C-n或C-p即可。 当弹出补全菜单后： C-p 向前切换成员； C-n 向后切换成员； C-e 退出下拉菜单，并退回到原来录入的文字； C-y 退出下拉菜单，并接受当前选项。 13.8 多行缩进缩出 正常模式下，按两下&gt;;光标所在行会缩进。 如果先按了n，再按两下&gt;;，光标以下的n行会缩进。 对应的，按两下&lt;;，光标所在行会缩出。 如果在编辑代码文件，可以用=进行调整。 在可视模式下，选择要调整的代码块，按=，代码会按书写规则缩排好。 或者n =，调整n行代码的缩排。 13.9 折叠 zf – 创建折叠的命令，可以在一个可视区域上使用该命令； zd – 删除当前行的折叠； zD – 删除当前行的折叠； zfap – 折叠光标所在的段； zo – 打开折叠的文本； zc – 收起折叠； za – 打开/关闭当前折叠； zr – 打开嵌套的折行； zm – 收起嵌套的折行； zR (zO) – 打开所有折行； zM (zC) – 收起所有折行； zj – 跳到下一个折叠处； zk – 跳到上一个折叠处； zi – enable/disable fold; 14. 命令行normal模式下按:进入命令行模式 14.1 命令行模式下的快捷键： 上下方向键：上一条或者下一条命令。如果已经输入了部分命令，则找上一 条或者下一条匹配的命令。 左右方向键：左/右移一个字符。 C-w： 向前删除一个单词。 C-h： 向前删除一个字符，等同于Backspace。 C-u： 从当前位置移动到命令行开头。 C-b： 移动到命令行开头。 C-e： 移动到命令行末尾。 Shift-Left： 左移一个单词。 Shift-Right： 右移一个单词。 @： 重复上一次的冒号命令。 q： 正常模式下，q然后按’:’，打开命令行历史缓冲区， 可以像编辑文件一样编辑命令。 q/和q? 可以打开查找历史记录。 14.2 执行外部命令 :! cmd 执行外部命令。 :!! 执行上一次的外部命令。 :sh 调用shell，用exit返回vim。 :r !cmd 将命令的返回结果插入文件当前位置。 :m,nw !cmd 将文件的m行到n行之间的内容做为命令输入执行命令。 15. 其它15.1 工作目录 :pwd 显示vim的工作目录。 :cd path 改变vim的工作目录。 :set autochdir 可以让vim 根据编辑的文件自动切换工作目录。 15.2 一些快捷键（收集中） K: 打开光标所在词的manpage。 *: 向下搜索光标所在词。 g*: 同上，但部分符合即可。 #: 向上搜索光标所在词。 g#: 同上，但部分符合即可。 g C-g: 统计全文或统计部分的字数。 15.3 在线帮助 :h(elp)或F1 打开总的帮助。 :help user-manual 打开用户手册。 命令帮助的格式为：第一行指明怎么使用那个命令； 然后是缩进的一段解释这个命令的作用，然后是进一步的信息。 :helptags somepath 为somepath中的文档生成索引。 :helpgrep 可以搜索整个帮助文档，匹配的列表显示在quickfix窗口中。 Ctrl+] 跳转到tag主题，Ctrl+t 跳回。 :ver 显示版本信息。 15.4 一些小功能 简单计算器: 在插入模式下，输入C-r =，然后输入表达式，就能在 光标处得到计算结果。","tags":[{"name":"linux","slug":"linux","permalink":"http://lcf12307.github.io/tags/linux/"},{"name":"快捷键","slug":"快捷键","permalink":"http://lcf12307.github.io/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"name":"云服务器","slug":"云服务器","permalink":"http://lcf12307.github.io/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]},{"title":"go语言规范","date":"2019-02-19T16:00:00.000Z","path":"2019/02/20/面试/要点整理/精选面试题/","text":"1. 系统知识系统知识主要用于评判候选人是否为资深软件工程师 1.1 网络考察对象: 工作三年以上 1.1.1 网络七层模型又称OSI 模型，从下到上分别为： 物理层：底层数据传输，如网线；网卡标准。 数据链路层：定义数据的基本格式，如何传输，如何标识；如网卡MAC地址。 网络层：定义IP编址，定义路由功能；如不同设备的数据转发。 传输层：端到端传输数据的基本功能；如 TCP、UDP。 会话层：控制应用程序之间会话能力；如不同软件数据分发给不同软件。 标识层：数据格式标识，基本压缩加密功能。 应用层：各种应用软件，包括 Web 应用。 1.1.2 网络四层模型从下到上分别为： 网络访问层：ARP、RARP等协议 互联网层：ICMP、IP等协议 传输层：TCP、UDP等协议 应用层：DNS、FTP、HTTP、SMTP、TELNET、IRC、WHOIS等协议 1.1.3 TCP、UDP、IP 协议 TCP与UDP的区别 TCP属于有状态的可靠连接，通过ack、拆包组包机制保障数据按照顺序传递，一旦建立好连接，路由路线是固定的；UDP本身是无状态的不可靠连接，没有固定的路由路线，优先选择速度快的路由路线，顺序靠应用程序自己保障。 TCP是基于数据流的，对应用层来说没有固定包大小，在TCP内部会发生拆包组包；UDP是基于数据包的，对应用程序来说有固定大小，UDP内部不会发生拆包组包。但不管是TCP还是UDP，在IP层都有可能发生拆包组包。 TCP粘包问题 发送端需要等缓冲区满才发送出去，造成粘包（nalge算法也可能造成粘包现象），可以通过设置socket为 nodelay解决。 接收方不及时接收缓冲区的包，造成多个包接收。应用程序对每个数据包添加包头来区分数据界限解决。 TCP拆包问题 发送的TCP报文大于TCP发送缓冲区剩余空间大小。 缓冲区中待发送的数据大小大于MSS（最大报文长度） 拆包问题，可以通过压缩数据得到改善。 TCP快速重传、快速恢复、慢启动、滑动窗口 TCP使用滑动窗口机制进行拥塞控制，避免网络质量变差时ACK时间过长导致丢包以及网络质量变好时频繁的ACK导致网络速度无法提升。 所谓的慢启动是指滑动窗口的调整是缓慢的调整，即使是网络质量很好的情况下，滑动窗口调整到合适大小也是需要一定时间。 快速重传：接收方接收到无序的包时，会立即发送ACK给发送方请求重传缺失的包，如果发送方连续收到3个或者3个以上的重传ACK，那么就判定丢包了，立即重传丢失的包。 快速恢复：丢包意味着网络环境变差，默认情况下TCP会恢复到慢启动来进行重传。快速恢复算法在收到3个重传ACK的时候判定网络环境质量并不差，决定不恢复到慢启动，直接重传丢失的包。 IP层拆包组包 当报文超过MTU（最大传输单元）大小时，将发生IP层的拆包组包。MTU由路由协商决定，取路由两端以太网帧大小中较小的值。 1.1.4 TCP端口快速回收与重用由于http协议是短连接，请求完毕后会关闭连接，导致服务器频繁的建立、断开连接，而TCP的回收是有等待时间的，在高并发的http服务器上，我们需要对TCP连接进行调优。否则，容易出现大量time_wait状态的连接占用大量资源。 123456789# 开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭net.ipv4.tcp_syncookies &#x3D; 1# 开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭net.ipv4.tcp_tw_reuse &#x3D; 1# 开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。net.ipv4.tcp_tw_recycle &#x3D; 1# 修改系統默认的TIMEOUT时间net.ipv4.tcp_fin_timeout &#x3D; 30net.ipv4.tcp_timestamps &#x3D; 1 服务端程序监听端口的socket也可能会遇到回收慢的问题。服务因意外挂掉没及时关闭socket，导致重启时无法监听端口。可以在代码里设置socket的reuse参数 1.2 系统调用与函数调用考察对象: 工作三年以上 附加考察点：应用程序地址空间的划分 应用程序地址空间的最高1G的内存空间是内核态内存空间，其余的属于用户态内存空间。内核态内存空间主要用于系统调用时在内核态保存数据。 1.2.1 系统调用系统调用是指通过软中断调用系统内核函数的过程。 应用程序调用C函数库中的函数（GO例外，GO自己封装了系统库函数） C函数库中触发软中断 INT 0x80，把系统调用号放入 %eax 寄存器 保存应用程序上下文到应用程序栈内存，主要是保存各种寄存器的值，其中最重要的是程序计数器（PC）和栈指针寄存器（SP） 陷入内核态 调用copy_from_user将参数从用户态内存复制到内核态内存 调用内核函数 调用copy_to_user将返回值从内核态内存复制到用户态内存 返回用户态 恢复应用程序上下文，并将PC所指内存地址的指令加载到指令寄存器（IP） 继续执行应用程序 1.2.2 函数调用函数调用是指给定特定参数调用函数功能并获取返回结果的过程。 保存函数参数到函数栈帧 保存函数调用完成后执行的下一条指令的地址到栈帧 跳转到函数地址 执行函数体 将返回值保存到栈帧 从栈帧加载下一条指令地址 执行下一条指令 1.2.3 系统调用与函数调用的区别 函数调用不需要触发软中断 函数调用不需要执行上下文切换 系统调用是调用系统内核函数，函数调用是调用应用程序的函数 1.3 并发与并行并发：某一时间段内处理多个任务的能力。 并行：某一时间点处理多个任务的能力。 1.3.1 并发并发强调的是单个处理单元在单位时间内处理任务的能力。常见的并发场景有： 单个CPU核单位时间内执行的任务（线程）数。如通过top查看到的load avrage在一定程度上反馈了CPU的并发数 单个服务器单位时间内处理的请求数。如QPS这一指标一定程度上衡量了一台服务器的处理能力。 1.3.2 并行并行强调的是整个系统某一时间点同时处理任务的能力。常见的并行场景有： CPU的指令流水线同时处理的指令数。如三级流水线表示整个流水线能同时处理三条指令：取指（加载指令）、预处理、执行。 CORE I7 处理器4核8线程，能同时让8个线程在上面工作。 一个拥有10个节点的集群，能同时处理至少10个网络请求。 1.3.3 多线程同步原因：CPU内核有缓存，现代多核CPU缓存中寄存器、L1缓存是独占的，L2、L3缓存是多核共享。多线程不同步的原因本质上是CPU核之间缓存不同步、CPU缓存与内存不同步。 解决方案：1、加锁，强制同步CPU核之间的缓存，适合复杂数据类型。2、volatile关键字，禁止寄存器优化，适合简单数据类型（如整数），但只能降低概率，并不能保证原子性。3、原子操作，CPU利用内存屏障，在CPU对内容进行“读-修改-写”这一连续操作时，锁定内存总线，屏蔽其他的读写操作。内存屏障分为读屏障（load barrier）、写屏障（store barrier）、全屏障（full barrier）。读屏障是加在指令前强制让CPU缓存失效，直接从内存读取；写屏障是加在指令后强制将CPU缓存中的数据写入到内存。 2. 架构能力考察对象：工作五年以上 架构能力考察候选人软件架构方面的知识和能力。 2.1 分布式与集群集群：多个处理相同任务的节点组成集群。 分布式：多个处理不同子任务的节点组成分布式系统。 分布式系统中往往涉及关键数据的同步，需要用到分布式锁。 2.1.1 分布式锁分布式锁基本理论：CAP、悲观锁、乐观锁（CAS） CAP：任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance），最多只能同时满足两项。 CAS： compare and swap，比较并交换。在修改正式数据之前，先会把现有数据版本与修改前的数据版本比较：如果相等则执行修改操作；如果不相等则需要重新获取数据和版本并提交CAS请求。 悲观锁：假设所有操作都可能会修改数据，默认执行加锁操作，直到等待锁释放后才能加锁成功。相当于互斥锁。 乐观锁：假设所有操作中读操作远比写操作多，在修改数据之前检查条件，条件符合则执行修改操作，条件不符合则返回失败。 常用的分布式锁主要有以下几种 基于redis、memcached等缓存实现 redis的悲观锁： 加锁 1setnx test 1 ，如果test已经存在，则返回0表示加锁失败。解锁 1del test redis的乐观锁： 123456watchmultiset test 1get testexecunwatch 判断get test的返回值是否为 set 的值来判断是否加锁成功 基于zookeeper、etcd等集群管理软件实现 etcd 的悲观锁： 123451. 创建一个key2. 如果key不存在返回成功并执行第 5 步3. 如果key存在则返回失败，需要watch这个key等待key被删除4. 如果key被删除则重试第 1 步5. 执行需要的操作 etcd 的乐观锁： 1231. 读取数据以及数据的版本号 ModifiedIndex2. 修改数据时用ModifiedIndex作为数据的比较条件3. 如果ModifiedIndex与现有数据的相同，则修改成功；否则修改失败，重试第 1 步 etcd v3 已经提供了lock和unlock的接口 基于mysql等数据库实现 悲观锁： 12SELECT * FROM methodLock WHERE method_name&#x3D;xxx FOR UPDATEUPDATE tb_stock SET number&#x3D;number-1 乐观锁： 1update tb_stock set number&#x3D;number-1 where product_id&#x3D;xxx 2.2 微服务 SOA：服务注册与发现、配置管理 ETCD、zookeeper的用法 RPC：微服务调用 thrift、protobuf、grpc的原理和用法 MQ：异步调用、日志收集 rabbitmq、kafka的架构和用法 容器：服务调度和治理 docker、kubernetes的原理和用法 3. 编程语言3.1 PHP3.2 Golang考察点： go调度器模型 channel的各种用法 goroutine的各种用法 interface的各种用法 sync包的用法 time包定时器的用法 context包用法和实现原理 3.2.1 Golang的调度器模型用这个知识点来初步判断候选人是否真的对golang感兴趣并了解过golang 3.2.2 channel种类 nil 值为nil的channel，读写都会block。主要用于select的时候将close掉的channel置为nil，防止触发相应case。 无缓冲 读写都会block，读操作在写操作之前完成。一般用于同步通知。 12345678ch :&#x3D; make(chan struct&#123;&#125;)go func()&#123; &#x2F;&#x2F;do something close(ch)&#125;()&#x2F;&#x2F;wait goroutine finish&lt;- ch&#x2F;&#x2F;do something 单缓冲 无数据时，读操作block；有数据时，写操作block。用于保证数据有序传递并且限制接收端的最大速度。 多缓冲 只要缓冲区有数据，读操作不会被block；即使有数据，只要缓冲区有空间，写操作不会被block。可以保证数据有序传递，但无法限制接收端的最大速度，只能限制接收端的平均速度。 3.2.3 goroutine4. 数据库4.1 关联查询 内联结：将两个表中存在联结关系的字段符合联结关系的那些记录形成记录集的联结。 123SELECT A.Name B.Hobby FROM A, B WHERE A.id &#x3D; B.id或者SELECT A.Name FROM A INNER JOIN B ON A.id &#x3D; B.id 外联结：分为外左联结和外右联结。 123SELECT A.Name FROM A LEFT JOIN B ON A.id &#x3D; B.id或者SELECT A.Name FROM B RIGHT JOIN A ON A.id &#x3D; B.id 全联结：将两个表中存在联结关系的字段的所有记录取出形成记录集的联结。 mysql本身没有实现全联结，可以使用左连接 union 右连接来实现 12SELECT L.*,r.* FROM left_table L LEFT JOIN right_table r on L.age&#x3D;r.age UNIONSELECT L.*,r.* FROM left_table L RIGHT JOIN right_table r on L.age&#x3D;r.age 无联结：没有使用联结功能，也有自联结的说法。 假如要取两个用户共同评论过的商品详情，如何写SQL语句？ 4.2 事务4.2.1 ACID特性 原子性（Atomicity） 原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚。 一致性（Consistency） 一致性是指事务必须使数据库从一个一致的状态变到另外一个一致的状态，也就是执行事务之前和之后的状态都必须处于一致的状态。 隔离性(Isolation) 隔离性是指当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离 持久性(Durability) 持久性是指一个事务一旦被提交了，那么对于数据库中的数据改变就是永久性的，即便是在数据库系统遭遇到故障的情况下也不会丢失提交事务的操作。 4.2.2 事务的使用1234set autocommit &#x3D; 0;start transaction;update accout set money&#x3D;money+100 where name&#x3D;&quot;Jason&quot;;commit; 4.2.3 事务的回滚1234set autocommit &#x3D; 0;start transaction;update account set money&#x3D;money-100 where name&#x3D;&quot;justin&quot;;rollback; 4.4.4 事务隔离级别查询 1select @@tx_isolation; 设置当前session的下一个事务的隔离级别 1set transaction isolation level Read uncommitted; 设置当前session以后所有事务的隔离级别 1set session transaction isolation level Read uncommitted; 设置之后的所有session的隔离级别，不包括当前session 1set global transaction isolation level Read uncommitted; 4.3 索引4.4 锁4.4.1 锁方案 一次封锁：可以避免大量并发情况下的死锁，前提条件是已知要在哪些数据加锁，不适合用在数据库事务中。 两段锁：两段锁协议将事务分成两个阶段：加锁阶段和解锁阶段。在事务开始时加锁，事务结束后解锁。无法避免死锁，但能保证事务的串行化。 4.4.2 锁类型 表锁：对一整张表加锁，并发能力低下（即使有分读锁、写锁），一般在DDL处理时使用。 行锁：只锁住特定行的数据，并发能力强，MySQL一般都是用行锁来处理并发事务。 GAP锁（间隙锁）：是MySQL使用索引对行锁两边的区间进行加锁，避免其他事务在这两个区间insert的一种锁。 Next-Key锁：Next-Key锁是行锁和GAP锁的合并（MySQL使用它来避免幻读） MVVC(多版本并发控制）：Innodb中的乐观锁实现。通过它提高MySQL的读取操作的性能。并能解决MySQL的重复读问题。 5. 缓存5.1 缓存金字塔从上到下速度由快到慢，容量由小到大 寄存器 L1缓存 L2缓存、L3缓存 系统缓存：缓存系统元数据和文件数据。 内存缓存：redis、memcached等使用内存来保存数据的缓存 磁盘缓存：交换分区、缓存文件等 网络缓存：CDN等通过网络来访问的缓存 5.2 http请求的缓存过程从上到下优先级从高到低 浏览器内存缓存 浏览器文件缓存 浏览器DNS缓存 CDN缓存 nginx缓存 web服务缓存 redis缓存 数据库缓存 6. web开发 http缓存 http状态码 web后端框架 websocket建立过程 http2基本原理 7. 数据结构和算法 树操作：前序遍历、中序遍历、后序遍历；平衡二叉树调整子节点 堆：TopN 问题 数组：快排、归并 8. shell脚本 awk 输出第一列、第二列、最后一列，用一个空格隔开。 逐行读取文件，在每行行首添加行号，用空格隔开","tags":[{"name":"go","slug":"go","permalink":"http://lcf12307.github.io/tags/go/"}]},{"title":"go使用protocbuf","date":"2019-02-17T16:00:00.000Z","path":"2019/02/18/常见问题/云服务器/git常见命令/","text":"git checkout . #本地所有修改的。没有的提交的，都返回到原来的状态 git stash #把所有没有提交的修改暂存到stash里面。可用git stash pop回复。 git reset –hard HASH #返回到某个节点，不保留修改。 git reset –soft HASH #返回到某个节点。 保留修改git clean -df #返回到某个节点 git clean 参数-n 显示 将要 删除的文件和目录-f 删除 文件-df 删除文件和目录 1234567回退命令：$ git reset --hard HEAD^ 回退到上个版本$ git reset --hard HEAD~3 回退到前3次提交之前，以此类推，回退到n次提交之前$ git reset --hard commit_id 退到/进到 指定commit的sha码强推到远程：$ git push origin HEAD --force","tags":[{"name":"云服务器","slug":"云服务器","permalink":"http://lcf12307.github.io/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"git","slug":"git","permalink":"http://lcf12307.github.io/tags/git/"}]},{"title":"配置mysql远程访问","date":"2018-09-05T16:00:00.000Z","path":"2018/09/06/常见问题/云服务器/配置mysql远程访问权限/","text":"1.使用yum命令安装mysql 1[root@bogon ~]# yum -y install mysql-server 2.设置开机启动 1[root@bogon ~]# chkconfig mysqld on 3.启动MySQL服务 1[root@bogon ~]# service mysqld start 4.设置MySQL的root用户设置密码 123456789101112[root@bogon ~]# mysql -u root mysql&gt; select user,host,password from mysql.user; +------+-----------+----------+ | user | host | password | +------+-----------+----------+ | root | localhost | | | root | bogon | | | root | 127.0.0.1 | | | | localhost | | | | bogon | | +------+-----------+----------+ 5 rows in set (0.01 sec) 查询用户的密码，都为空，用下面的命令设置root的密码为root 12mysql&gt; set password for root@localhost&#x3D;password(&#39;root&#39;); mysql&gt; exit 6.创建mysql新用户test_user 12mysql&gt; create user &#39;test_user&#39;@&#39;%&#39; identified by &#39;test_user&#39;; Query OK, 0 rows affected (0.00 sec) 7.给新用户test_user授权，让他可以从外部登陆和本地登陆注意：@左边是用户名，右边是域名、IP和%，表示可以访问mysql的域名和IP，%表示外部任何地址都能访问。 12345678910111213141516171819mysql&gt; grant all privileges on *.* to &#39;test_user&#39;@&#39;localhost&#39; identified by &#39;test_user&#39;; Query OK, 0 rows affected (0.00 sec) mysql&gt; grant all privileges on *.* to &#39;test_user&#39;@&#39;%&#39; identified by &#39;test_user&#39;; Query OK, 0 rows affected (0.00 sec) mysql&gt; select user,host,password from mysql.user; +----------+-----------+-------------------------------------------+ | user | host | password | +----------+-----------+-------------------------------------------+ | root | localhost | *81F5E21E35407D884A6CD4A731AEBFB6AF209E1B | | root | bogon | | | root | 127.0.0.1 | | | | localhost | | | | bogon | | | test_user | % | *3046CF87132BBD4FDDF06F321C6859074843B7D3 | | test_user | localhost | *3046CF87132BBD4FDDF06F321C6859074843B7D3 | +----------+-----------+-------------------------------------------+ 7 rows in set (0.00 sec) mysql&gt; flush privileges; Query OK, 0 rows affected (0.01 sec) 8.查看mysql5.1的默认存储引擎从下面的执行结果可以看出，mysql的默认引擎是MyISAM，这个引擎是不支持事务的。 1234567891011mysql&gt; show engines; +------------+---------+------------------------------------------------------------+--------------+------+------------+ | Engine | Support | Comment | Transactions | XA | Savepoints | +------------+---------+------------------------------------------------------------+--------------+------+------------+ | MRG_MYISAM | YES | Collection of identical MyISAM tables | NO | NO | NO | | CSV | YES | CSV storage engine | NO | NO | NO | | MyISAM | DEFAULT | Default engine as of MySQL 3.23 with great performance | NO | NO | NO | | InnoDB | YES | Supports transactions, row-level locking, and foreign keys | YES | YES | YES | | MEMORY | YES | Hash based, stored in memory, useful for temporary tables | NO | NO | NO | +------------+---------+------------------------------------------------------------+--------------+------+------------+ 5 rows in set (0.00 sec) 也可以以下面的方式查看 1234567mysql&gt; show variables like &#39;storage_engine&#39;; +----------------+--------+ | Variable_name | Value | +----------------+--------+ | storage_engine | MyISAM | +----------------+--------+ 1 row in set (0.00 sec) 9.修改mysql的默认引擎为InnoDB9.1 停止mysql 12mysql&gt; exit; [root@bogon ~]# service mysqld stop 9.2 修改/etc/my.cnf[mysqld] 后加入 1default-storage-engine=InnoDB 加入后my.cnf的内容为： 12345678910111213[root@bogon etc]# more my.cnf [mysqld] datadir=/var/lib/mysql socket=/var/lib/mysql/mysql.sock user=mysql # Disabling symbolic-links is recommended to prevent assorted security risks symbolic-links=0 default-storage-engine=InnoDB [mysqld_safe] log-error=/var/log/mysqld.log pid-file=/var/run/mysqld/mysqld.pid 9.3 启动mysql 12[root@bogon etc]# service mysqld start Starting mysqld: [ OK ] 9.4 查看mysql默认存储引擎 123456789101112131415161718192021[root@bogon etc]# mysql -u root -p Enter password: Welcome to the MySQL monitor. Commands end with ; or \\g. Your MySQL connection id is 2 Server version: 5.1.73 Source distribution Copyright (c) 2000, 2013, Oracle and&#x2F;or its affiliates. All rights reserved. Oracle is a registered trademark of Oracle Corporation and&#x2F;or its affiliates. Other names may be trademarks of their respective owners. Type &#39;help;&#39; or &#39;\\h&#39; for help. Type &#39;\\c&#39; to clear the current input statement. mysql&gt; show variables like &#39;storage_engine&#39;; +----------------+--------+ | Variable_name | Value | +----------------+--------+ | storage_engine | InnoDB | +----------------+--------+ 1 row in set (0.00 sec) 10.CentOS6.5开放mysql端口3306CentOS6.5默认是不开放端口的，如果要让外部的系统访问CentOS6.5上的mysql，必须开放mysql的端口330610.1 修改/etc/sysconfig/iptables添加下面一行 1-A INPUT -m state --state NEW -m tcp -p tcp --dport 3306 -j ACCEPT 修改后iptables中的内容是 12345678910111213141516171819[root@bogon etc]# more &#x2F;etc&#x2F;sysconfig&#x2F;iptables # Firewall configuration written by system-config-firewall # Manual customization of this file is not recommended. *filter :INPUT ACCEPT [0:0] :FORWARD ACCEPT [0:0] :OUTPUT ACCEPT [0:0] -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT -A INPUT -p icmp -j ACCEPT -A INPUT -i lo -j ACCEPT -A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT #添加配置项 -A INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT -A INPUT -m state --state NEW -m tcp -p tcp --dport 11211 -j ACCEPT -A INPUT -m state --state NEW -m tcp -p tcp --dport 3306 -j ACCEPT -A INPUT -j REJECT --reject-with icmp-host-prohibited -A FORWARD -j REJECT --reject-with icmp-host-prohibited COMMIT 11.重启防火墙 1[root@bogon etc]# service iptables restart 这样就可以从外部访问mysql了。 至此，mysql在CentOS6.5上的安装过程、用户创建、外部访问的步骤全部完成。 —————————分割线————————————— 上面都是从别人发表的文章中截取的~作者要是看到了莫怪，我只是想收藏，怕源文被删就看不到了，谢谢你们这些摘树的前人。 其实这样在云主机上设置mysql并访问是OK的。适用于一切的centos6.5，亦或者其他linux系统。万变不离其宗，系统的改变，无非是命令行语言的改变，其宗旨是不会变的。 LZ第一次用云主机，想试试在本地远程访问一下，结果发现，咦，连接出错了~，后来试了很多方法，还是没有能成功。 刚开始，用Navicat连接远程数据库，出现如下错误：应该就是远程不允许访问了。 远程拒绝访问的情况可能有两种： 一、mysql设置中，不允许远程访问.也即你使用的mysql登陆账号没有远程访问的权限。比如root账号，在我们之前看到的use权限列表中，root就没有远程访问的权限。现在来设置root的远程访问权限。 方法一：实现远程连接(授权法) mysql&gt; use mysql; Database changed mysql&gt; grant all privileges on . to root@’%’ identified by “root”; mysql&gt; select host,user,password from user; +————–+——+——————————————-+ | host | user | password | +————–+——+——————————————-+ | localhost | root | *A731AEBFB621E354CD41BAF207D884A609E81F5E | | 192.168.1.1 | root | *A731AEBFB621E354CD41BAF207D884A609E81F5E | | % | root | *A731AEBFB621E354CD41BAF207D884A609E81F5E | +————–+——+——————————————-+ 3 rows in set (0.00 sec) 这样机器就可以以用户名root密码root远程访问该机器上的MySql. 方法二：实现远程连接（改表法） 将host字段的值改为%就表示在任何客户端机器上能以root用户登录到mysql服务器，建议在开发时设为%。 mysql&gt; use mysql; Database changed mysql&gt; update user set host = ‘%’ where user = ‘root’; 这时，root将权限改为ALL PRIVILEGES； 这样在远端就可以通过root用户访问Mysql. 二、确定服务器上的防火墙没有阻止 3306 端口。也即服务器上面有没有开放mysql的端口~（我的就是这个问题） 看到上面的第10条中，在端口管理iptables中添加3306端口的开放配置，这样算是硬件的配置。然后看看你的云主机设置里面有没有开放对应的端口，或者说是不是开放了所有端口~我的云主机如下图： ) 腾讯云主机中，貌似是没有开放所有端口的，所以需要我们自己在这里稍微设置一下，勾选“默认安全组放通全部端口”选项，“确定”。基本上，我们能做的都做了，要不然就是配置文件出错了，再返回去看看。设置好了以后，我去试了一下连接，结果成功了~ 哈哈，好高兴以后遇到这些问题就知道在哪些地方找问题了","tags":[{"name":"mysql","slug":"mysql","permalink":"http://lcf12307.github.io/tags/mysql/"},{"name":"linux","slug":"linux","permalink":"http://lcf12307.github.io/tags/linux/"},{"name":"云服务器","slug":"云服务器","permalink":"http://lcf12307.github.io/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]},{"title":"nginx 403报错","date":"2018-08-22T16:00:00.000Z","path":"2018/08/23/常见问题/云服务器/nginx403/","text":"由于开发需要，在本地环境中配置了LNMP环境，使用的是Centos 6.5 的yum安装，安装一切正常，但是由于默认网站文件夹比较奇葩，于是把网站文件用mv命令移动到了新的目录，并相应修改了配置文件，并重启Nginx。 那么好，问题来了！本以为重启就OK了。居然报个“403 is forbidden“的错误。。查看/var/log/nginx/error.log日志显示：xxx 403 forbidden (13: Permission denied)错误。我勒个去~ 引起nginx 403 forbidden通常是三种情况：一是缺少索引文件，二是权限问题，三是SELinux状态。 一、缺少index.html或者index.php文件，就是配置文件中index index.html index.htm这行中的指定的文件。 我是按照腾讯云官网文档进行配置的， 官网上应该给index增加index.php 索引文件，此外最好设置权限","tags":[{"name":"linux","slug":"linux","permalink":"http://lcf12307.github.io/tags/linux/"},{"name":"云服务器","slug":"云服务器","permalink":"http://lcf12307.github.io/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"nginx","slug":"nginx","permalink":"http://lcf12307.github.io/tags/nginx/"}]},{"title":"访问php直接下载，而不是访问","date":"2018-08-22T16:00:00.000Z","path":"2018/08/23/常见问题/云服务器/访问php直接下载/","text":"遇到这种问题，首先确认你web服务器配置中的.php是不是被指定给FastCGI server处理： location ~ .php$ {fastcgi_pass 127.0.0.1:9000; } 如已配置，那么可能是由于fastcgi_script_name访问脚本路径不正确引起的。 尤其是带有子目录的情况，比如对于Yii框架而言，路径通常是project/web 那么如果在URL中访问 /project/index.php，那么nginx配置中的SCRIPT_NAME会是全路径：project/index.php 如果你配置中的代码如下： fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; 那么实际访问的文件就是/var/site_root/project/web/project/index.php，这显然不是我们想要的结果，我们想访问的是/project/web/index.php。 这些错误可以通过查看php-fpm.log（错误日志）来跟踪。 解决方法是修改相应的路径配置。 此时我们先在查看下错误日志 error.log，发现里面都是清一色的报错： connect() failed (111: Connection refused) while connecting to upstream …… fastcgi://127.0.0.1:9000 …… 提示的意思就是说连接不上9000端口，这就奇怪了，其实在平时配置nginx的server里面，大部分应该都是配置127.0.0.1:9000 作为分发端口。 现在需要查看一下是否有监听9000端口： [root@izwz9glf2r6p2z8ytslvblz /]# netstat -ant | grep 9000发现并没有监听到，但实际上我们的php-fpm已经启动，那现在怎么办呢？我们去查看一下php-fpm.conf里面的配置： [root@izwz9glf2r6p2z8ytslvblz /]# vim /usr/local/php/etc/php-fpm.conf 找到listen：/tmp/php-cgi.sock 此时我们需要根据配置文件的listen地址做对应的修改： location ~ .php$ {fastcgi_pass 127.0.0.1:9000;fastcgi_index index.php;fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;include fastcgi_params; } 改成：location ~ .php$ {fastcgi_pass unix:/tmp/php-cgi.sock;fastcgi_index index.php;fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;include fastcgi_params;} 重启nginx。访问成功。","tags":[{"name":"php","slug":"php","permalink":"http://lcf12307.github.io/tags/php/"},{"name":"linux","slug":"linux","permalink":"http://lcf12307.github.io/tags/linux/"},{"name":"云服务器","slug":"云服务器","permalink":"http://lcf12307.github.io/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"nginx","slug":"nginx","permalink":"http://lcf12307.github.io/tags/nginx/"}]},{"title":"linux命令-scp","date":"2018-08-16T16:00:00.000Z","path":"2018/08/17/常见问题/云服务器/linux命令-scp/","text":"scp是secure copy的简写，用于在Linux下进行远程拷贝文件的命令，和它类似的命令有cp，不过cp只是在本机进行拷贝不能跨服务器，而且scp传输是加密的。可能会稍微影响一下速度。当你服务器硬盘变为只读 read only system时，用scp可以帮你把文件移出来。另外，scp还非常不占资源，不会提高多少系统负荷，在这一点上，rsync就远远不及它了。虽然 rsync比scp会快一点，但当小文件众多的情况下，rsync会导致硬盘I/O非常高，而scp基本不影响系统正常使用。 1．命令格式： scp [参数] [原路径] [目标路径] 2．命令功能： scp是 secure copy的缩写, scp是linux系统下基于ssh登陆进行安全的远程文件拷贝命令。linux的scp命令可以在linux服务器之间复制文件和目录。 3．命令参数： -1 强制scp命令使用协议ssh1 -2 强制scp命令使用协议ssh2 -4 强制scp命令只使用IPv4寻址 -6 强制scp命令只使用IPv6寻址 -B 使用批处理模式（传输过程中不询问传输口令或短语） -C 允许压缩。（将-C标志传递给ssh，从而打开压缩功能） -p 保留原文件的修改时间，访问时间和访问权限。 -q 不显示传输进度条。 -r 递归复制整个目录。 -v 详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。 -c cipher 以cipher将数据传输进行加密，这个选项将直接传递给ssh。 -F ssh_config 指定一个替代的ssh配置文件，此参数直接传递给ssh。 -i identity_file 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。 -l limit 限定用户所能使用的带宽，以Kbit/s为单位。 -o ssh_option 如果习惯于使用ssh_config(5)中的参数传递方式， -P port 注意是大写的P, port是指定数据传输用到的端口号 -S program 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。 4．使用实例： scp命令的实际应用概述： 从本地服务器复制到远程服务器： (1) 复制文件： 命令格式： scp local_file remote_username@remote_ip:remote_folder 或者 scp local_file remote_username@remote_ip:remote_file 或者 scp local_file remote_ip:remote_folder 或者 scp local_file remote_ip:remote_file 第1,2个指定了用户名，命令执行后需要输入用户密码，第1个仅指定了远程的目录，文件名字不变，第2个指定了文件名 第3,4个没有指定用户名，命令执行后需要输入用户名和密码，第3个仅指定了远程的目录，文件名字不变，第4个指定了文件名 (2) 复制目录： 命令格式： scp -r local_folder remote_username@remote_ip:remote_folder 或者 scp -r local_folder remote_ip:remote_folder 第1个指定了用户名，命令执行后需要输入用户密码； 第2个没有指定用户名，命令执行后需要输入用户名和密码； 从远程服务器复制到本地服务器： 从远程复制到本地的scp命令与上面的命令雷同，只要将从本地复制到远程的命令后面2个参数互换顺序就行了。 实例1：从远处复制文件到本地目录 命令： scp root@192.168.120.204:/opt/soft/nginx-0.5.38.tar.gz /opt/soft/ 输出：","tags":[{"name":"linux","slug":"linux","permalink":"http://lcf12307.github.io/tags/linux/"},{"name":"云服务器","slug":"云服务器","permalink":"http://lcf12307.github.io/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]},{"title":"Ubuntu 安装vs code","date":"2018-07-18T16:00:00.000Z","path":"2018/07/19/常见问题/ubuntu安装vscode/","text":"ubuntu16.04安装visual-studio-code微软主页的安装说明，https://code.visualstudio.com/docs/setup/linux 有一点英语基础就能看懂，写的很好，一切以官方文档为主 方法一：可以使用umake，（要先安装，非常牛逼的工具，可以安装很多种流行的开发工具） sudo apt install ubuntu-make umake web visual-studio-code ,会问你安装目录，回车即可，接受，完成安装，快捷方式会出现在快速启动栏，不过有个问题，我不懂如何命令行启动，这让我用的不舒服。 umake -r web visual-studio-code 即可删除 方法二：或者到微软的vscode网站 （下载地址）https://code.visualstudio.com/Download，即可安装，可以使用（ 命令行输入code . 在任何目录中打开该编辑器，只用deb安装的可以命令行打开，其他不行） 推荐使用这种方法，bug最少，启动最方便 方法三：或者直接下载一个.zip文件，双击一个叫code的可执行文件即可。 感觉非常棒，但是换编辑器太花时间，而且atom已经用的比较习惯了，所以先放一放。 如果不能安装成功，可以看一看参考Arun Pyasi的文章，他写的更详细，网址http://os.51cto.com/art/201509/490032.htm","tags":[{"name":"应用安装","slug":"应用安装","permalink":"http://lcf12307.github.io/tags/%E5%BA%94%E7%94%A8%E5%AE%89%E8%A3%85/"}]},{"title":"Ubuntu Navicat for MySQL安装以及破解方案","date":"2018-07-17T16:00:00.000Z","path":"2018/07/18/常见问题/ubuntu安装navicat/","text":"今天安装了Navicat for MySQL有LINUX版本了哈， 开心的说， 首先上官网上下载LINUX版本： http://www.navicat.com/download/navicat-for-mysql 下载 navicat110_mysql_en.tar.gz 文件 下载后解压tar文件 1tar -zxvf /home/rain/download/navicat8_mysql_en.tar.gz 解压后 进入解压后的目录运行命令： 1./start_navicat OK，这样就完啦 连接上数据库后里面的中文数据是乱码,把Ubuntu的字符集修改为zh_CN.utf8就行了,修改方法: 1.查看系统支持的字符集: locale -a 2,修改字符集: export LANG=zh_CN.utf8 破解方案： 第一次执行start_navicat时，会在用户主目录下生成一个名为.navicat的隐藏文件夹。 cd /home/rain/.navicat/ 此文件夹下有一个system.reg文件 rm system.reg 把此文件删除后，下次启动navicat 会重新生成此文件，30天试用期会按新的时间开始计算。 问题：Linux下MySQL workbench连接数据库，表中数据不乱码，但是我下载安装类Navicat for mysql 64位 英文版，其中显示的中文数据乱码 解决步骤：1、下载好navicat112_mysql_en_x64.tar.gz压缩文件，解压出文件，我用的命令是 tar xvf navicat112_mysql_en_x64.tar.gz2、我连接上mysql数据库，其中表中字段有中文全部乱码，打开navicat112_mysql_en_x64.tar.gz解压的目录，用文本编辑器方式打开start_navicat会看到 export LANG=”en_US.UTF-8”，改为export LANG=”zh_CN.UTF-8”，然后保存。3、打开navicat，新建连接，对连接进行 Edit Connection ，Advanced 其中到Encoding 我选择的是Auto 4、保存之后，打开数据库表中数据中文数据显示正常。","tags":[{"name":"mysql","slug":"mysql","permalink":"http://lcf12307.github.io/tags/mysql/"},{"name":"应用安装","slug":"应用安装","permalink":"http://lcf12307.github.io/tags/%E5%BA%94%E7%94%A8%E5%AE%89%E8%A3%85/"}]},{"title":"【常见问题】Ubuntu下利用deepin-wine安装软件简要方案","date":"2018-07-12T06:51:25.000Z","path":"2018/07/12/常见问题/ubuntu安装wine应用/","text":"一直以来，Linux作为开发机比较给力，但是常用软件(如QQ、微信等)的缺乏使Linux在桌面端一直不火，用户量低于Windows以及macOS，今天分享一个Ubuntu下安装常用软件的方法。 博主电脑环境 Ubuntu 18.10 x64 教程安装deepin-wine输入以下命令即可 复制 123 git clone https://github.com/wszqkzqk/deepin-wine-ubuntu.gitcd deepin-wine-ubuntu./install 安装软件 下载软件(GUI下载或wget等均可)http://mirrors.aliyun.com/deepin/pool/non-free/ 使用如下命令安装软件 复制 1 sudo dpkg -i xxx.deb 目前博主已经成功安装Tim、微信、百度网盘、迅雷精简版、foobar2000等。 或者： https://github.com/hillwoodroc/winetricks-zh","tags":[{"name":"wine","slug":"wine","permalink":"http://lcf12307.github.io/tags/wine/"},{"name":"linux","slug":"linux","permalink":"http://lcf12307.github.io/tags/linux/"}]},{"title":"linux多命令连接","date":"2018-07-05T16:00:00.000Z","path":"2018/07/06/常见问题/云服务器/linux多命令连接/","text":"当我们需要一次执行多个命令的时候，命令之间需要用连接符连接，不同的连接符有不同的效果。下面我们总结一下，加以区分。 (1) ; 分号，没有任何逻辑关系的连接符。当多个命令用分号连接时，各命令之间的执行成功与否彼此没有任何影响，都会一条一条执行下去。 (2) || 逻辑或，当用此连接符连接多个命令时，前面的命令执行成功，则后面的命令不会执行。前面的命令执行失败，后面的命令才会执行。 (3) &amp;&amp; 逻辑与，当用此连接符连接多个命令时，前面的命令执行成功，才会执行后面的命令，前面的命令执行失败，后面的命令不会执行，与 || 正好相反。 (4) | 管道符，当用此连接符连接多个命令时，前面命令执行的正确输出，会交给后面的命令继续处理。若前面的命令执行失败，则会报错，若后面的命令无法处理前面命令的输出，也会报错。 例 ls | grep *.txt 在linux中，&amp;和&amp;&amp;,|和||介绍如下： &amp; 表示任务在后台执行，如要在后台运行redis-server,则有 redis-server &amp; &amp;&amp; 表示前一条命令执行成功时，才执行后一条命令 ，如 echo ‘1‘ &amp;&amp; echo ‘2’ | 表示管道，上一条命令的输出，作为下一条命令参数，如 echo ‘yes’ | wc -l || 表示上一条命令执行失败后，才执行下一条命令，如 cat nofile || echo “fail”","tags":[{"name":"linux","slug":"linux","permalink":"http://lcf12307.github.io/tags/linux/"},{"name":"云服务器","slug":"云服务器","permalink":"http://lcf12307.github.io/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]},{"title":"linux搜索","date":"2018-07-05T16:00:00.000Z","path":"2018/07/06/常见问题/云服务器/linux搜索命令/","text":"Ubuntu的which、whereis、locate和find命令 which 只能寻找执行文件 ，并在PATH变量里面寻找。 whereis 从linux文件数据库（/var/lib/slocate/slocate.db）寻找，所以有可能找到刚刚删除，或者没有发现新建的文件。 locate 同上,不过文件名是部分匹配。 find 是直接在硬盘上搜寻，功能强大，但耗硬盘，一般不要用。","tags":[{"name":"linux","slug":"linux","permalink":"http://lcf12307.github.io/tags/linux/"},{"name":"云服务器","slug":"云服务器","permalink":"http://lcf12307.github.io/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]},{"title":"mysql 忘记密码","date":"2018-05-22T16:00:00.000Z","path":"2018/05/23/常见问题/云服务器/mysql忘记密码/","text":"mysql 忘记密码时，如何进行恢复 I. 在终端输入sudo gedit /etc/mysql/mysql.conf.d/mysqld.cnf II. 在[mysqld]下方的skip-external-locking下面添加一行： skip-grant-tables III. 重启MySQL服务： sudo service mysql restart IV. 在终端输入命令：mysql 进入mysql V. 输入USE mysql （切换至mysql数据库） VI. 将root用户的密码修改为0000： UPDATE mysql.user SET authentication_string=password(‘0000’) WHERE User=’root’ AND Host =’localhost’; VII. 修改字段plugin： UPDATE user SET plugin=”mysql_native_password”; （Plugin字段标识可以用于验证用户身份的插件，如果字段为空，服务器使用内建授权验证机制验证用户身份。 ） VIII. 输入flush privileges; IX. 输入quit; X. 把/etc/mysql/mysql.conf.d/mysqld.cnf文件中添加的一行注释掉-——————–作者：rhanqtlnuse来源：CSDN原文：https://blog.csdn.net/hq815601489/article/details/78608644版权声明：本文为博主原创文章，转载请附上博文链接！","tags":[{"name":"mysql","slug":"mysql","permalink":"http://lcf12307.github.io/tags/mysql/"},{"name":"linux","slug":"linux","permalink":"http://lcf12307.github.io/tags/linux/"},{"name":"云服务器","slug":"云服务器","permalink":"http://lcf12307.github.io/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]}]