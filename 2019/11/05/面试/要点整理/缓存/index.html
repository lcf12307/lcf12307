<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>【第一课】缓存 | fannnnnn</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="redis,memcache,缓存">
    <meta name="description" content="本篇文章主要就redis的常见面试问题进行了讨论">
<meta property="og:type" content="article">
<meta property="og:title" content="【第一课】缓存">
<meta property="og:url" content="http://lcf12307.github.io/2019/11/05/%E9%9D%A2%E8%AF%95/%E8%A6%81%E7%82%B9%E6%95%B4%E7%90%86/%E7%BC%93%E5%AD%98/index.html">
<meta property="og:site_name" content="fannnnnn">
<meta property="og:description" content="本篇文章主要就redis的常见面试问题进行了讨论">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2019-11-04T16:00:00.000Z">
<meta property="article:modified_time" content="2021-06-22T15:55:01.013Z">
<meta property="article:author" content="chavey Liu">
<meta property="article:tag" content="redis">
<meta property="article:tag" content="memcache">
<meta property="article:tag" content="缓存">
<meta name="twitter:card" content="summary">
    
        <link rel="alternate" type="application/atom+xml" title="fannnnnn" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">chavey Liu</h5>
          <a href="mailto:lcf12307@sina.com" title="lcf12307@sina.com" class="mail">lcf12307@sina.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/lcf12307" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">【第一课】缓存</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="Search">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">【第一课】缓存</h1>
        <h5 class="subtitle">
            
                <time datetime="2019-11-04T16:00:00.000Z" itemprop="datePublished" class="page-time">
  2019-11-05
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#为什么用redis？"><span class="post-toc-number">1.</span> <span class="post-toc-text">为什么用redis？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#redis和memecache的区别"><span class="post-toc-number">2.</span> <span class="post-toc-text">redis和memecache的区别</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#为什么要用缓存？"><span class="post-toc-number">3.</span> <span class="post-toc-text">为什么要用缓存？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#缓存这么好，为什么不都用缓存"><span class="post-toc-number">4.</span> <span class="post-toc-text">缓存这么好，为什么不都用缓存</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#缓存适用的场景"><span class="post-toc-number">5.</span> <span class="post-toc-text">缓存适用的场景</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#缓存穿透"><span class="post-toc-number">6.</span> <span class="post-toc-text">缓存穿透</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#缓存击穿"><span class="post-toc-number">7.</span> <span class="post-toc-text">缓存击穿</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#缓存防雪崩"><span class="post-toc-number">8.</span> <span class="post-toc-text">缓存防雪崩</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#redis的新增数据结构"><span class="post-toc-number">9.</span> <span class="post-toc-text">redis的新增数据结构</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#如果有大量的key需要设置同一时间过期，一般需要注意什么？"><span class="post-toc-number">10.</span> <span class="post-toc-text">如果有大量的key需要设置同一时间过期，一般需要注意什么？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#那你使用过Redis分布式锁么，它是什么回事？"><span class="post-toc-number">11.</span> <span class="post-toc-text">那你使用过Redis分布式锁么，它是什么回事？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#然后接着问如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？"><span class="post-toc-number">12.</span> <span class="post-toc-text">然后接着问如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？"><span class="post-toc-number">13.</span> <span class="post-toc-text">假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？"><span class="post-toc-number">14.</span> <span class="post-toc-text">如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#使用redis怎么实现异步队列？"><span class="post-toc-number">15.</span> <span class="post-toc-text">使用redis怎么实现异步队列？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#可不可以不用sleep"><span class="post-toc-number">16.</span> <span class="post-toc-text">可不可以不用sleep</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#能不能一次生产-多次消费"><span class="post-toc-number">17.</span> <span class="post-toc-text">能不能一次生产 多次消费</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#pub-sub有什么缺点"><span class="post-toc-number">18.</span> <span class="post-toc-text">pub&#x2F;sub有什么缺点</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Redis如何实现延时队列？"><span class="post-toc-number">19.</span> <span class="post-toc-text">Redis如何实现延时队列？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#redis怎么持久化的-主从数据怎么进行交互？"><span class="post-toc-number">20.</span> <span class="post-toc-text">redis怎么持久化的 主从数据怎么进行交互？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#突然停电怎么办"><span class="post-toc-number">21.</span> <span class="post-toc-text">突然停电怎么办</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#rdb的原理"><span class="post-toc-number">22.</span> <span class="post-toc-text">rdb的原理</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Pipline的好处是什么"><span class="post-toc-number">23.</span> <span class="post-toc-text">Pipline的好处是什么</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#redis的同步机制"><span class="post-toc-number">24.</span> <span class="post-toc-text">redis的同步机制</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#redis集群的高可用怎么保证，-原理是什么"><span class="post-toc-number">25.</span> <span class="post-toc-text">redis集群的高可用怎么保证， 原理是什么</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#pika和redis"><span class="post-toc-number">26.</span> <span class="post-toc-text">pika和redis</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#从pika迁移到pika"><span class="post-toc-number">27.</span> <span class="post-toc-text">从pika迁移到pika</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#redis数据过期的问题"><span class="post-toc-number">28.</span> <span class="post-toc-text">redis数据过期的问题</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#如果定期删除漏掉了很多过期-key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期-key-堆积在内存里，导致-redis-内存块耗尽了，咋整？"><span class="post-toc-number">29.</span> <span class="post-toc-text">如果定期删除漏掉了很多过期 key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期 key 堆积在内存里，导致 redis 内存块耗尽了，咋整？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#实现lru"><span class="post-toc-number">30.</span> <span class="post-toc-text">实现lru</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#哨兵机制"><span class="post-toc-number">31.</span> <span class="post-toc-text">哨兵机制</span></a></li></ol>
        </nav>
    </aside>


<article id="post-面试/要点整理/缓存"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">【第一课】缓存</h1>
        <div class="post-meta">
            <time class="post-time" title="2019-11-05 00:00:00" datetime="2019-11-04T16:00:00.000Z"  itemprop="datePublished">2019-11-05 </time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <blockquote>
<p>本篇文章主要就redis的常见面试问题进行了讨论</p>
</blockquote>
<a id="more"></a>

<h2 id="为什么用redis？"><a href="#为什么用redis？" class="headerlink" title="为什么用redis？"></a>为什么用redis？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为传统的关系型数据库如Mysql已经不能适用所有的场景了，比如秒杀的库存扣减，APP首页的访问流量高峰等等，都很容易把数据库打崩，所以引入了缓存中间件，目前市面上比较常用的缓存中间件有 **Redis** 和 **Memcached** 不过中和考虑了他们的优缺点，最后选择了Redis。</span><br></pre></td></tr></table></figure>

<h2 id="redis和memecache的区别"><a href="#redis和memecache的区别" class="headerlink" title="redis和memecache的区别"></a>redis和memecache的区别</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">存储方式 Memecache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。Redis有部份存在硬盘上，这样能保证数据的持久性。</span><br><span class="line">数据支持类型 Memcache对数据类型支持相对简单。Redis有复杂的数据类型。redis的数据类型更多string,set,zset, list, hash, ， memcache只支持简单字符串</span><br><span class="line">使用底层模型不同 它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。</span><br><span class="line">value大小 redis最大可以达到1GB，而memcache只有1MB</span><br><span class="line">redis支持数据备份 即主从备份</span><br><span class="line">redis支持数据的持久化 可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。</span><br></pre></td></tr></table></figure>



<h2 id="为什么要用缓存？"><a href="#为什么要用缓存？" class="headerlink" title="为什么要用缓存？"></a>为什么要用缓存？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对于一个服务其性能瓶颈往往都在DB，传统关系型存储尤甚。我们在创建表的时候，并不会未所有的字段创建索引，这意味着如果我们需要读取非缓存数据就要从磁盘拿数据。这个过程至少需要十几毫秒的时间。而缓存往往是基于内存的，这要比DB读数据快两个数量级。这是我们用缓存的根本原因原因。</span><br></pre></td></tr></table></figure>



<h2 id="缓存这么好，为什么不都用缓存"><a href="#缓存这么好，为什么不都用缓存" class="headerlink" title="缓存这么好，为什么不都用缓存"></a>缓存这么好，为什么不都用缓存</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">内存这东西虽然很快，同时它还很贵。动辄百十来G的数据都扔内存这有点太浪费。依据二八定律，我们只需找到那最紧俏的百分之二十就行了。这是非常重要的。否则你加了缓存效果反而更差。对于缓存有一个衡量指标，叫做缓存命中率。这个指标高说明我们请求的数据大部分来自缓存。证明我们加缓存这件事的收益越高。</span><br></pre></td></tr></table></figure>



<h2 id="缓存适用的场景"><a href="#缓存适用的场景" class="headerlink" title="缓存适用的场景"></a>缓存适用的场景</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">会话缓存 如存储用户购物车中的数据的时候，利用redis持久化的特点，使其不会丢失数据。</span><br><span class="line">全页缓存 缓存页内数据</span><br><span class="line">队列 利用redis的list数据结构的push&#x2F;pop操作， 对数据进行操作</span><br><span class="line">排行榜 利用zset数据结构进行rank排行操作</span><br><span class="line">计数器 使用set来统计集合内的数据量</span><br><span class="line">订阅发布 利用订阅发布功能功能甚至可以搭建聊天室</span><br></pre></td></tr></table></figure>

<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">缓存穿透指的是如果我们访问一个缓存中没有的数据的时候就会去查询数据库， 如果数据库里也没有的话，一般是不更新缓存的， 这时候如果用户一直刷就会造成缓存穿透</span><br><span class="line">缓存空对象 或者缓存预测</span><br></pre></td></tr></table></figure>



<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">多个用户同时访问一个热点缓存，在这个key失效的瞬间 就会造成多次访问数据库， 造成缓存击穿。</span><br><span class="line">缓存预热 缓存加锁</span><br></pre></td></tr></table></figure>



<h2 id="缓存防雪崩"><a href="#缓存防雪崩" class="headerlink" title="缓存防雪崩"></a>缓存防雪崩</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">缓存服务暂时崩溃，导致大量请求访问数据库。</span><br><span class="line">采用高可用的缓存方案 限流</span><br></pre></td></tr></table></figure>



<h2 id="redis的新增数据结构"><a href="#redis的新增数据结构" class="headerlink" title="redis的新增数据结构"></a>redis的新增数据结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">geo 地理索引 基于zset</span><br><span class="line">HyperLogLog 寻找集合中的基数，即去重后的数据</span><br><span class="line">pub&#x2F;sub 发布订阅，如上文</span><br></pre></td></tr></table></figure>



<h2 id="如果有大量的key需要设置同一时间过期，一般需要注意什么？"><a href="#如果有大量的key需要设置同一时间过期，一般需要注意什么？" class="headerlink" title="如果有大量的key需要设置同一时间过期，一般需要注意什么？"></a>如果有大量的key需要设置同一时间过期，一般需要注意什么？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果我们过期时间设在同一时间，很有可能会造成缓存雪崩，大量访问指向数据库， 我们给定时时间一个随机值</span><br></pre></td></tr></table></figure>



<h2 id="那你使用过Redis分布式锁么，它是什么回事？"><a href="#那你使用过Redis分布式锁么，它是什么回事？" class="headerlink" title="那你使用过Redis分布式锁么，它是什么回事？"></a>那你使用过Redis分布式锁么，它是什么回事？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">先使用setnx争抢锁 用expire给这个key添加过期时间，防止忘记释放。</span><br></pre></td></tr></table></figure>



<h2 id="然后接着问如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？"><a href="#然后接着问如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？" class="headerlink" title="然后接着问如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？"></a>然后接着问如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这时候这个锁就永远无法释放了。 可以通过set里的nx,ex两个命令行参数来进行原子化操作。</span><br></pre></td></tr></table></figure>



<h2 id="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？"><a href="#假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？" class="headerlink" title="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？"></a>假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用keys命令可以扫出制定模式的</span><br></pre></td></tr></table></figure>



<h2 id="如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？"><a href="#如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？" class="headerlink" title="如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？"></a>如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis是单线程的，线上会停顿，直到这个指令结束。 使用scan可以无阻塞的提出指定模式的keys，但是可能会重复</span><br></pre></td></tr></table></figure>



<h2 id="使用redis怎么实现异步队列？"><a href="#使用redis怎么实现异步队列？" class="headerlink" title="使用redis怎么实现异步队列？"></a>使用redis怎么实现异步队列？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用list数据类型， rpush 发送消息， lpop接收消息， 接收不到消息的时候适当的sleep一段时间</span><br></pre></td></tr></table></figure>



<h2 id="可不可以不用sleep"><a href="#可不可以不用sleep" class="headerlink" title="可不可以不用sleep"></a>可不可以不用sleep</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list有个指令 blpop 可以在消息不来的时候阻塞住知道消息到来</span><br></pre></td></tr></table></figure>



<h2 id="能不能一次生产-多次消费"><a href="#能不能一次生产-多次消费" class="headerlink" title="能不能一次生产 多次消费"></a>能不能一次生产 多次消费</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用pub&#x2F;sub模式，可以实现1:n的消息队列</span><br></pre></td></tr></table></figure>



<h2 id="pub-sub有什么缺点"><a href="#pub-sub有什么缺点" class="headerlink" title="pub/sub有什么缺点"></a>pub/sub有什么缺点</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一旦消费者下线， 消息就会丢失。 建议还是使用专业的消息队列， \**RocketMQ rabbitmq\*</span><br></pre></td></tr></table></figure>



<h2 id="Redis如何实现延时队列？"><a href="#Redis如何实现延时队列？" class="headerlink" title="Redis如何实现延时队列？"></a>Redis如何实现延时队列？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用zset 值为时间戳 key为消息内容 使用zadd添加消息 使用zrangebyscore获取n秒前的数据。</span><br></pre></td></tr></table></figure>



<h2 id="redis怎么持久化的-主从数据怎么进行交互？"><a href="#redis怎么持久化的-主从数据怎么进行交互？" class="headerlink" title="redis怎么持久化的 主从数据怎么进行交互？"></a>redis怎么持久化的 主从数据怎么进行交互？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rdb进行镜像全量同步， aof做增量持久化。 因为rdb耗费时间较久 需要配合aof来使用。 当redis重启时， 使用rdb持久化文件重新构建内存， 再用aof重放近期的操作指令来恢复重启前的状态</span><br></pre></td></tr></table></figure>



<h2 id="突然停电怎么办"><a href="#突然停电怎么办" class="headerlink" title="突然停电怎么办"></a>突然停电怎么办</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">取决于 aof的sync配置，如果不考虑性能的话每条指令后都sync下就不会丢失，但是一般来说，不会这么配置，如果配置每秒同步一次的话，丢失的就是这一秒的数据</span><br></pre></td></tr></table></figure>



<h2 id="rdb的原理"><a href="#rdb的原理" class="headerlink" title="rdb的原理"></a>rdb的原理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fork 和 cow 父进程fork一个子进程，并且开始进行rdb， 子进程创建后，父子共享数据段， 父进程继续进行读写操作。</span><br><span class="line">redis每隔几分钟形成一个快照</span><br><span class="line"></span><br><span class="line">- rdb</span><br><span class="line">保存了redis某个时间点的数据集合， 体积较小</span><br><span class="line">适合用于灾难回复 恢复大量数据的时候比aof快 但是会丢失数据</span><br><span class="line"></span><br><span class="line">- aof</span><br><span class="line">同步频率快且不影响redis性能。</span><br><span class="line">有序追加对redis的操作指令</span><br><span class="line">但是体积较大</span><br></pre></td></tr></table></figure>



<h2 id="Pipline的好处是什么"><a href="#Pipline的好处是什么" class="headerlink" title="Pipline的好处是什么"></a>Pipline的好处是什么</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以把多次io缩减为1次</span><br></pre></td></tr></table></figure>



<h2 id="redis的同步机制"><a href="#redis的同步机制" class="headerlink" title="redis的同步机制"></a>redis的同步机制</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">主从同步和从从同步， 主节点做一次bgsave，生成rdb镜像， 并保存后续的操作记录。 待完成后，主节点把rdb全量同步给复制节点， 复制节点加载完rdb后， 增量数据使用aof同步。</span><br></pre></td></tr></table></figure>



<h2 id="redis集群的高可用怎么保证，-原理是什么"><a href="#redis集群的高可用怎么保证，-原理是什么" class="headerlink" title="redis集群的高可用怎么保证， 原理是什么"></a>redis集群的高可用怎么保证， 原理是什么</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Redis Sentinal 着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。   </span><br><span class="line">Redis Cluster  着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。</span><br></pre></td></tr></table></figure>



<h2 id="pika和redis"><a href="#pika和redis" class="headerlink" title="pika和redis"></a>pika和redis</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">pika相对于redis，最大的不同就是pika是持久化存储，数据存在磁盘上，而redis是内存存储，由此不同也给pika带来了相对于redis的优势和劣势**</span><br><span class="line"></span><br><span class="line">大容量redis 遇到的问题</span><br><span class="line"></span><br><span class="line">- 恢复时间长</span><br><span class="line">- 一主多从, 主从切换代价大</span><br><span class="line">- 缓冲区写满问题</span><br><span class="line">- 内存太贵</span><br><span class="line"></span><br><span class="line">Pika的特点</span><br><span class="line"></span><br><span class="line">1. 容量大，支持百G数据量的存储</span><br><span class="line">2. 兼容Redis，不用修改代码即可平滑从Redis迁移到Pika</span><br><span class="line">3. 支持主从(slaveof)</span><br><span class="line">4. 完善的运维命令</span><br><span class="line"></span><br><span class="line">优势:</span><br><span class="line"></span><br><span class="line">- 容量大：Pika没有Redis的内存限制, 最大使用空间等于磁盘空间的大小**</span><br><span class="line">- 加载db速度快：Pika 在写入的时候, 数据是落盘的, 所以即使节点挂了, 不需要rbd或者aof，pika 重启不用重新加载数据到内存而是直接使用已经持久化在磁盘上的数据, 不需要任何数据回放操作，这大大降低了重启成本。**</span><br><span class="line">- 备份速度快：Pika备份的速度大致等同于cp的速度（拷贝数据文件后还有一个快照的恢复过程，会花费一些时间），这样在对于百G大库的备份是快捷的，更快的备份速度更好的解决了主从的全同步问题</span><br><span class="line"></span><br><span class="line">劣势：</span><br><span class="line"></span><br><span class="line">由于Pika是基于内存和文件来存放数据, 所以性能肯定比Redis低一些, 但是我们一般使用SSD盘来存放数据, 尽可能跟上Redis的性能。</span><br><span class="line"></span><br><span class="line">从以上的对比可以看出, 如果你的业务场景的数据比较大，Redis 很难支撑， 比如大于50G，或者你的数据很重要，不允许断电丢失，那么使用Pika 就可以解决你的问题。</span><br><span class="line">而在实际使用中，大多数场景下pika的性能大约是Redis的50%~80%，在某些特定场景下，例如range 500，pika的性能只有redis的20%，针对这些场景我们仍然在改进</span><br></pre></td></tr></table></figure>



<h2 id="从pika迁移到pika"><a href="#从pika迁移到pika" class="headerlink" title="从pika迁移到pika"></a>从pika迁移到pika</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> DBA需要做的</span><br><span class="line"></span><br><span class="line"><span class="bullet">1. </span>DBA迁移Redis数据到Pika</span><br><span class="line"><span class="bullet">2. </span>DBA将Redis的数据实时同步到Pika，确保Redis与Pika的数据始终一致</span><br><span class="line"><span class="bullet">3. </span>DBA切换LVS后端ip，由Pika替换Redis</span><br></pre></td></tr></table></figure>

<h2 id="redis数据过期的问题"><a href="#redis数据过期的问题" class="headerlink" title="redis数据过期的问题"></a>redis数据过期的问题</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在单机版Redis中，存在两种删除策略：</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>惰性删除：服务器不会主动删除数据，只有当客户端查询某个数据时，服务器判断该数据是否过期，如果过期则删除。</span><br><span class="line"><span class="bullet">- </span>定期删除：服务器执行定时任务删除过期数据，但是考虑到内存和CPU的折中（删除会释放内存，但是频繁的删除操作对CPU不友好），该删除的频率和执行时间都受到了限制。</span><br><span class="line"></span><br><span class="line">在主从复制场景下，为了主从节点的数据一致性，从节点不会主动删除数据，而是由主节点控制从节点中过期数据的删除。由于主节点的惰性删除和定期删除策略，都不能保证主节点及时对过期数据执行删除操作，因此，当客户端通过Redis从节点读取数据时，很容易读取到已经过期的数据。</span><br></pre></td></tr></table></figure>



<h2 id="如果定期删除漏掉了很多过期-key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期-key-堆积在内存里，导致-redis-内存块耗尽了，咋整？"><a href="#如果定期删除漏掉了很多过期-key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期-key-堆积在内存里，导致-redis-内存块耗尽了，咋整？" class="headerlink" title="如果定期删除漏掉了很多过期 key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期 key 堆积在内存里，导致 redis 内存块耗尽了，咋整？"></a>如果定期删除漏掉了很多过期 key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期 key 堆积在内存里，导致 redis 内存块耗尽了，咋整？</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">内存淘汰机制。</span><br><span class="line"></span><br><span class="line">redis 内存淘汰机制有以下几个：</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>noeviction: 当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用吧，实在是太恶心了。</span><br><span class="line"><span class="bullet">- </span>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）。</span><br><span class="line"><span class="bullet">- </span>allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个 key，这个一般没人用吧，为啥要随机，肯定是把最近最少使用的 key 给干掉啊。</span><br><span class="line"><span class="bullet">- </span>volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 key（这个一般不太合适）。</span><br><span class="line"><span class="bullet">- </span>volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 key。</span><br><span class="line"><span class="bullet">- </span>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 key 优先移除。</span><br></pre></td></tr></table></figure>



<h2 id="实现lru"><a href="#实现lru" class="headerlink" title="实现lru"></a>实现lru</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">使用链表来实现， 当命中某个值的时候 把它移到链表头部， 淘汰尾部</span><br><span class="line"></span><br><span class="line">lru-k 使用两个队列，一个是访问历史队列，先进先出</span><br><span class="line"></span><br><span class="line">一个lru队列</span><br></pre></td></tr></table></figure>



<h2 id="哨兵机制"><a href="#哨兵机制" class="headerlink" title="哨兵机制"></a>哨兵机制</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">为了解决redis主从复制模式致命缺点，当主节点宕机，影响整个系统运行，引入哨兵机制Sentinel。</span><br><span class="line"></span><br><span class="line">Sentinel哨兵主要解决以下问题：</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>监控，监控每个节点以及哨兵运行状态</span><br><span class="line"><span class="bullet">- </span>报警，当发现某个节点或哨兵出现问题，通知其他哨兵</span><br><span class="line"><span class="bullet">- </span>自动故障转化，当主节点宕机时，哨兵从原主节点下的所有可用从节点中选举出一个作为主节点，原主节点降为从节点，并将其他从节点的主节点配置改为指定新主节点</span><br><span class="line"><span class="bullet">- </span>配置中心，客户端初始化连接的是哨兵节点集合</span><br></pre></td></tr></table></figure>



<hr>
<hr>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        

        
        行到水穷处，坐看云起时
        
    </div>
    
    <footer>
        <a href="http://lcf12307.github.io">
            <img src="/img/avatar.jpg" alt="chavey Liu">
            chavey Liu
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/memcache/" rel="tag">memcache</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BC%93%E5%AD%98/" rel="tag">缓存</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://lcf12307.github.io/2019/11/05/%E9%9D%A2%E8%AF%95/%E8%A6%81%E7%82%B9%E6%95%B4%E7%90%86/%E7%BC%93%E5%AD%98/&title=《【第一课】缓存》 — fannnnnn&pic=http://lcf12307.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://lcf12307.github.io/2019/11/05/%E9%9D%A2%E8%AF%95/%E8%A6%81%E7%82%B9%E6%95%B4%E7%90%86/%E7%BC%93%E5%AD%98/&title=《【第一课】缓存》 — fannnnnn&source=
本篇文章主要就redis的常见面试问题进行了讨论
" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://lcf12307.github.io/2019/11/05/%E9%9D%A2%E8%AF%95/%E8%A6%81%E7%82%B9%E6%95%B4%E7%90%86/%E7%BC%93%E5%AD%98/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《【第一课】缓存》 — fannnnnn&url=http://lcf12307.github.io/2019/11/05/%E9%9D%A2%E8%AF%95/%E8%A6%81%E7%82%B9%E6%95%B4%E7%90%86/%E7%BC%93%E5%AD%98/&via=http://lcf12307.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://lcf12307.github.io/2019/11/05/%E9%9D%A2%E8%AF%95/%E8%A6%81%E7%82%B9%E6%95%B4%E7%90%86/%E7%BC%93%E5%AD%98/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2019/11/06/%E9%9D%A2%E8%AF%95/%E8%A6%81%E7%82%B9%E6%95%B4%E7%90%86/%E7%BD%91%E7%BB%9C/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">【第一课】网络</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2019/07/21/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/wine%E5%BA%94%E7%94%A8%E6%97%A0%E6%B3%95%E8%BE%93%E5%85%A5%E4%B8%AD%E6%96%87/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">【常见问题】wine下的应用无法输入中文，解决办法</h4>
      </a>
    </div>
  
</nav>



    




















</article>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>This blog is licensed under a <a rel="license noopener" href="https://creativecommons.org/licenses/by/4.0/" target="_blank">Creative Commons Attribution 4.0 International License</a>.</span>
        </p>
    </div>
    <div class="bottom">
        <p><span>chavey Liu &copy; 2020 - 2021</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://lcf12307.github.io/2019/11/05/%E9%9D%A2%E8%AF%95/%E8%A6%81%E7%82%B9%E6%95%B4%E7%90%86/%E7%BC%93%E5%AD%98/&title=《【第一课】缓存》 — fannnnnn&pic=http://lcf12307.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://lcf12307.github.io/2019/11/05/%E9%9D%A2%E8%AF%95/%E8%A6%81%E7%82%B9%E6%95%B4%E7%90%86/%E7%BC%93%E5%AD%98/&title=《【第一课】缓存》 — fannnnnn&source=
本篇文章主要就redis的常见面试问题进行了讨论
" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://lcf12307.github.io/2019/11/05/%E9%9D%A2%E8%AF%95/%E8%A6%81%E7%82%B9%E6%95%B4%E7%90%86/%E7%BC%93%E5%AD%98/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《【第一课】缓存》 — fannnnnn&url=http://lcf12307.github.io/2019/11/05/%E9%9D%A2%E8%AF%95/%E8%A6%81%E7%82%B9%E6%95%B4%E7%90%86/%E7%BC%93%E5%AD%98/&via=http://lcf12307.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://lcf12307.github.io/2019/11/05/%E9%9D%A2%E8%AF%95/%E8%A6%81%E7%82%B9%E6%95%B4%E7%90%86/%E7%BC%93%E5%AD%98/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQ4AAAEOCAAAAABd2qZ5AAAD3UlEQVR42u3cS47bQAwFwLn/pZNNFgEmth/5qGAWpZXhkaXuUgCKH+TrKz5+/XV8//775++/yo/3v321nlfffD1x4MCBAweOeKv54l5d5/1S3t9lCrHD+rAXHDhw4MBxxNFs7/1mkvOnYf59WM2DLg4cOHDg+DkcfWDOU8RmhThw4MCB4+dzNDee0uTJ3tWLAg4cOHDguOJIAmeyjWnStWs45W2tB2ulOHDgwIEjjXRfu6D7kz8/Mt+BAwcOHDiGyVI/xLYrIPaNqOWIHg4cOHDgqDl2t+/TrV28u2pWfTgTBw4cOHDUHOPGTNHymW4133ZSjhykdjhw4MCBY8UxXWi+rGkgzNH70YqXDjhw4MCB44jjqiy4S66m6M31PzwwHDhw4MBRc+wStl14br7ZrWr3EoADBw4cOHqOaaMoT6KmzaQ8VZsG0UGhEAcOHDhwFBy7VlPeqdlduQnYVcqHAwcOHDhqjnwsYMrxfom7wmI/kDHIYnHgwIEDx2qFSdqzS8x2Awp9OK92hAMHDhw4HubYDQRMRyJy3Dxhq4qDOHDgwIGj4GiSq4Rg12RqgKZp4YexBhw4cODAUXPkC901e/LkMLlynuZN22A4cODAgeOWY3pMk6vp1ZrUbjqWgQMHDhw4bjl2DZvmnOkYxDT07shw4MCBA8eOI79BcrndcEOS+O2GIfLPf77BgQMHDhw1xzRxmm7+duhtep2D9w4cOHDgwFHnLE2y1zeWpgXB44ImDhw4cOA46g3tim5NGW5XOuyHGKJHhQMHDhw4jjiS8Dk9P4frR8Dzl4APjwcHDhw4cBQcu4bQbhgiavbUxcF8VVEXDgcOHDhwDDl2yc80kucL2m3sONnDgQMHDhwFx25xu8A8Da7TUL1LAl/+u8CBAwcOHI9xJEMA+QbyBG+aKE6D+suMFgcOHDhwPMBxm4xNt5eU/KYPIxpowIEDBw4cpxy7UYCrv+YJW36M004cOHDgwHFTwTv+rwGaQuEjXbX4weDAgQMHjp5jV6S7QszTyN343TiNxIEDBw4cRxz5GHRTEGzOTF4UGhocOHDgwHHFMW3wTIfeBnnk8ApNWfADEA4cOHDgKDh2jZzpIEJyZlPsawJ2NNCAAwcOHDjqRtQuuObETSidBuNdKRMHDhw4cDQcV0u/CoS7J9YUGXHgwIEDxxMcu/JcvqA8ZZqORzR8//gVDhw4cOD47xzT5KpvKV39KlohDhw4cOD47xx5Ma5J7d6H6unm83IhDhw4cOC44tgNMeTbzst5U9C+9YUDBw4cOG45pk2dpGA3RZwOK+yCbp4Q4sCBAweOFcdvL4TFB9uZ3KYAAAAASUVORK5CYII=" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>






<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '等你回来！';
            clearTimeout(titleTime);
        } else {
            document.title = '欢迎回来!';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
